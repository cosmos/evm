// Code generated by go-abi. DO NOT EDIT.

package contracts

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// handleOps((address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[])
	HandleOpsSelector = [4]byte{0x53, 0x2d, 0x3a, 0xc9}
)

// Big endian integer versions of function selectors
const (
	HandleOpsID = 1395473097
)

// EncodeUserOperationSlice encodes (address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[] to ABI bytes
func EncodeUserOperationSlice(value []UserOperation, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// SizeUserOperationSlice returns the encoded size of (address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[]
func SizeUserOperationSlice(value []UserOperation) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// DecodeUserOperationSlice decodes (address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[] from ABI bytes
func DecodeUserOperationSlice(data []byte) ([]UserOperation, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]UserOperation, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

var _ abi.Method = (*HandleOpsCall)(nil)

const HandleOpsCallStaticSize = 32

var _ abi.Tuple = (*HandleOpsCall)(nil)

// HandleOpsCall represents an ABI tuple
type HandleOpsCall struct {
	Ops []UserOperation
}

// EncodedSize returns the total encoded size of HandleOpsCall
func (t HandleOpsCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeUserOperationSlice(t.Ops)

	return HandleOpsCallStaticSize + dynamicSize
}

// EncodeTo encodes HandleOpsCall to ABI bytes in the provided buffer
func (value HandleOpsCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := HandleOpsCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Ops: (address,uint256,bytes,bytes,uint256,uint256,uint256,uint256,uint256,bytes,bytes)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeUserOperationSlice(value.Ops, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes HandleOpsCall to ABI bytes
func (value HandleOpsCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes HandleOpsCall from ABI bytes in the provided buffer
func (t *HandleOpsCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Ops
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Ops")
		}
		t.Ops, n, err = DecodeUserOperationSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t HandleOpsCall) GetMethodName() string {
	return "handleOps"
}

// GetMethodID returns the function id
func (t HandleOpsCall) GetMethodID() uint32 {
	return HandleOpsID
}

// GetMethodSelector returns the function selector
func (t HandleOpsCall) GetMethodSelector() [4]byte {
	return HandleOpsSelector
}

// EncodeWithSelector encodes handleOps arguments to ABI bytes including function selector
func (t HandleOpsCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], HandleOpsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewHandleOpsCall constructs a new HandleOpsCall
func NewHandleOpsCall(
	ops []UserOperation,
) *HandleOpsCall {
	return &HandleOpsCall{
		Ops: ops,
	}
}

// HandleOpsReturn represents the output arguments for handleOps function
type HandleOpsReturn struct {
	abi.EmptyTuple
}

// Event signatures
var (
	// UserOperationEvent(bytes32,address,bool)
	UserOperationEventEventTopic = common.Hash{0x98, 0x0a, 0x55, 0x8f, 0x47, 0xf5, 0x9a, 0x27, 0x18, 0x9b, 0x15, 0x63, 0x78, 0xa6, 0xcc, 0x54, 0xc9, 0xdb, 0x56, 0x93, 0xb1, 0x1a, 0xc5, 0x59, 0xc5, 0xfa, 0x9f, 0xb2, 0x9e, 0xb7, 0x87, 0x19}
)

// UserOperationEventEvent represents the UserOperationEvent event
var _ abi.Event = (*UserOperationEventEvent)(nil)

type UserOperationEventEvent struct {
	UserOperationEventEventIndexed
	UserOperationEventEventData
}

// NewUserOperationEventEvent constructs a new UserOperationEvent event
func NewUserOperationEventEvent(
	userOpHash [32]byte,
	sender common.Address,
	success bool,
) *UserOperationEventEvent {
	return &UserOperationEventEvent{
		UserOperationEventEventIndexed: UserOperationEventEventIndexed{
			UserOpHash: userOpHash,
			Sender:     sender,
		},
		UserOperationEventEventData: UserOperationEventEventData{
			Success: success,
		},
	}
}

// GetEventName returns the event name
func (e UserOperationEventEvent) GetEventName() string {
	return "UserOperationEvent"
}

// GetEventID returns the event ID (topic)
func (e UserOperationEventEvent) GetEventID() common.Hash {
	return UserOperationEventEventTopic
}

// UserOperationEvent represents an ABI event
type UserOperationEventEventIndexed struct {
	UserOpHash [32]byte
	Sender     common.Address
}

// EncodeTopics encodes indexed fields of UserOperationEvent event to topics
func (e UserOperationEventEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, UserOperationEventEventTopic)
	{
		// UserOpHash
		var hash common.Hash
		if _, err := abi.EncodeBytes32(e.UserOpHash, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	{
		// Sender
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.Sender, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of UserOperationEvent event from topics, ignore hash topics
func (e *UserOperationEventEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return fmt.Errorf("invalid number of topics for UserOperationEvent event: expected 3, got %d", len(topics))
	}
	if topics[0] != UserOperationEventEventTopic {
		return fmt.Errorf("invalid event topic for UserOperationEvent event")
	}
	var err error
	e.UserOpHash, _, err = abi.DecodeBytes32(topics[1][:])
	if err != nil {
		return err
	}
	e.Sender, _, err = abi.DecodeAddress(topics[2][:])
	if err != nil {
		return err
	}
	return nil
}

const UserOperationEventEventDataStaticSize = 32

var _ abi.Tuple = (*UserOperationEventEventData)(nil)

// UserOperationEventEventData represents an ABI tuple
type UserOperationEventEventData struct {
	Success bool
}

// EncodedSize returns the total encoded size of UserOperationEventEventData
func (t UserOperationEventEventData) EncodedSize() int {
	dynamicSize := 0

	return UserOperationEventEventDataStaticSize + dynamicSize
}

// EncodeTo encodes UserOperationEventEventData to ABI bytes in the provided buffer
func (value UserOperationEventEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserOperationEventEventDataStaticSize // Start dynamic data after static section
	// Field Success: bool
	if _, err := abi.EncodeBool(value.Success, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes UserOperationEventEventData to ABI bytes
func (value UserOperationEventEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserOperationEventEventData from ABI bytes in the provided buffer
func (t *UserOperationEventEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Success: bool
	t.Success, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}
