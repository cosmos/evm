// Code generated by go-abi. DO NOT EDIT.

package common

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// dummy((string,uint256),(string,uint256,uint8),(uint256,uint8),(uint64,uint64),(bytes,uint64,uint64,bool,bool),(bytes,uint64),(string,string,(string,uint256)[],string[],string[]))
	DummySelector = [4]byte{0x59, 0xd4, 0xfe, 0x1a}
)

// Big endian integer versions of function selectors
const (
	DummyID = 1507130906
)

const CoinStaticSize = 64

// Coin represents an ABI tuple
type Coin struct {
	Denom  string
	Amount *big.Int
}

// EncodedSize returns the total encoded size of Coin
func (t Coin) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return CoinStaticSize + dynamicSize
}

// EncodeTo encodes Coin to ABI bytes in the provided buffer
func (value Coin) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := CoinStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Coin to ABI bytes
func (value Coin) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Coin from ABI bytes in the provided buffer
func (t *Coin) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const DecStaticSize = 64

// Dec represents an ABI tuple
type Dec struct {
	Value     *big.Int
	Precision uint8
}

// EncodedSize returns the total encoded size of Dec
func (t Dec) EncodedSize() int {
	dynamicSize := 0

	return DecStaticSize + dynamicSize
}

// EncodeTo encodes Dec to ABI bytes in the provided buffer
func (value Dec) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DecStaticSize // Start dynamic data after static section
	// Field Value: uint256
	if _, err := abi.EncodeUint256(value.Value, buf[0:]); err != nil {
		return 0, err
	}

	// Field Precision: uint8
	if _, err := abi.EncodeUint8(value.Precision, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Dec to ABI bytes
func (value Dec) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Dec from ABI bytes in the provided buffer
func (t *Dec) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field Value: uint256
	t.Value, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Precision: uint8
	t.Precision, _, err = abi.DecodeUint8(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const DecCoinStaticSize = 96

// DecCoin represents an ABI tuple
type DecCoin struct {
	Denom     string
	Amount    *big.Int
	Precision uint8
}

// EncodedSize returns the total encoded size of DecCoin
func (t DecCoin) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return DecCoinStaticSize + dynamicSize
}

// EncodeTo encodes DecCoin to ABI bytes in the provided buffer
func (value DecCoin) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DecCoinStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	// Field Precision: uint8
	if _, err := abi.EncodeUint8(value.Precision, buf[64:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes DecCoin to ABI bytes
func (value DecCoin) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DecCoin from ABI bytes in the provided buffer
func (t *DecCoin) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Precision: uint8
	t.Precision, _, err = abi.DecodeUint8(data[64:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const HeightStaticSize = 64

// Height represents an ABI tuple
type Height struct {
	RevisionNumber uint64
	RevisionHeight uint64
}

// EncodedSize returns the total encoded size of Height
func (t Height) EncodedSize() int {
	dynamicSize := 0

	return HeightStaticSize + dynamicSize
}

// EncodeTo encodes Height to ABI bytes in the provided buffer
func (value Height) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := HeightStaticSize // Start dynamic data after static section
	// Field RevisionNumber: uint64
	if _, err := abi.EncodeUint64(value.RevisionNumber, buf[0:]); err != nil {
		return 0, err
	}

	// Field RevisionHeight: uint64
	if _, err := abi.EncodeUint64(value.RevisionHeight, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Height to ABI bytes
func (value Height) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Height from ABI bytes in the provided buffer
func (t *Height) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field RevisionNumber: uint64
	t.RevisionNumber, _, err = abi.DecodeUint64(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field RevisionHeight: uint64
	t.RevisionHeight, _, err = abi.DecodeUint64(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const ICS20AllocationStaticSize = 160

// ICS20Allocation represents an ABI tuple
type ICS20Allocation struct {
	SourcePort        string
	SourceChannel     string
	SpendLimit        []Coin
	AllowList         []string
	AllowedPacketData []string
}

// EncodedSize returns the total encoded size of ICS20Allocation
func (t ICS20Allocation) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.SourcePort)
	dynamicSize += abi.SizeString(t.SourceChannel)
	dynamicSize += SizeCoinSlice(t.SpendLimit)
	dynamicSize += abi.SizeStringSlice(t.AllowList)
	dynamicSize += abi.SizeStringSlice(t.AllowedPacketData)

	return ICS20AllocationStaticSize + dynamicSize
}

// EncodeTo encodes ICS20Allocation to ABI bytes in the provided buffer
func (value ICS20Allocation) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := ICS20AllocationStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field SourcePort: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.SourcePort, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field SourceChannel: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.SourceChannel, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field SpendLimit: (string,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeCoinSlice(value.SpendLimit, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field AllowList: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeStringSlice(value.AllowList, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field AllowedPacketData: string[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeStringSlice(value.AllowedPacketData, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes ICS20Allocation to ABI bytes
func (value ICS20Allocation) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes ICS20Allocation from ABI bytes in the provided buffer
func (t *ICS20Allocation) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode dynamic field SourcePort
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SourcePort")
		}
		t.SourcePort, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field SourceChannel
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SourceChannel")
		}
		t.SourceChannel, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field SpendLimit
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SpendLimit")
		}
		t.SpendLimit, n, err = DecodeCoinSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field AllowList
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field AllowList")
		}
		t.AllowList, n, err = abi.DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field AllowedPacketData
	{
		offset := int(binary.BigEndian.Uint64(data[128+24 : 128+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field AllowedPacketData")
		}
		t.AllowedPacketData, n, err = abi.DecodeStringSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const PageRequestStaticSize = 160

// PageRequest represents an ABI tuple
type PageRequest struct {
	Key        []byte
	Offset     uint64
	Limit      uint64
	CountTotal bool
	Reverse    bool
}

// EncodedSize returns the total encoded size of PageRequest
func (t PageRequest) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.Key)

	return PageRequestStaticSize + dynamicSize
}

// EncodeTo encodes PageRequest to ABI bytes in the provided buffer
func (value PageRequest) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := PageRequestStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Key: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Key, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Offset: uint64
	if _, err := abi.EncodeUint64(value.Offset, buf[32:]); err != nil {
		return 0, err
	}

	// Field Limit: uint64
	if _, err := abi.EncodeUint64(value.Limit, buf[64:]); err != nil {
		return 0, err
	}

	// Field CountTotal: bool
	if _, err := abi.EncodeBool(value.CountTotal, buf[96:]); err != nil {
		return 0, err
	}

	// Field Reverse: bool
	if _, err := abi.EncodeBool(value.Reverse, buf[128:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes PageRequest to ABI bytes
func (value PageRequest) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes PageRequest from ABI bytes in the provided buffer
func (t *PageRequest) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode dynamic field Key
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Key")
		}
		t.Key, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Offset: uint64
	t.Offset, _, err = abi.DecodeUint64(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Limit: uint64
	t.Limit, _, err = abi.DecodeUint64(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field CountTotal: bool
	t.CountTotal, _, err = abi.DecodeBool(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field Reverse: bool
	t.Reverse, _, err = abi.DecodeBool(data[128:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const PageResponseStaticSize = 64

// PageResponse represents an ABI tuple
type PageResponse struct {
	NextKey []byte
	Total   uint64
}

// EncodedSize returns the total encoded size of PageResponse
func (t PageResponse) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.NextKey)

	return PageResponseStaticSize + dynamicSize
}

// EncodeTo encodes PageResponse to ABI bytes in the provided buffer
func (value PageResponse) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := PageResponseStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field NextKey: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.NextKey, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Total: uint64
	if _, err := abi.EncodeUint64(value.Total, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes PageResponse to ABI bytes
func (value PageResponse) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes PageResponse from ABI bytes in the provided buffer
func (t *PageResponse) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field NextKey
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field NextKey")
		}
		t.NextKey, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Total: uint64
	t.Total, _, err = abi.DecodeUint64(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// EncodeCoinSlice encodes (string,uint256)[] to ABI bytes
func EncodeCoinSlice(value []Coin, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// SizeCoinSlice returns the encoded size of (string,uint256)[]
func SizeCoinSlice(value []Coin) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// DecodeCoinSlice decodes (string,uint256)[] from ABI bytes
func DecodeCoinSlice(data []byte) ([]Coin, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Coin, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

const DummyCallStaticSize = 288

// DummyCall represents an ABI tuple
type DummyCall struct {
	A Coin
	B DecCoin
	C Dec
	D Height
	E PageRequest
	F PageResponse
	G ICS20Allocation
}

// EncodedSize returns the total encoded size of DummyCall
func (t DummyCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.A.EncodedSize()
	dynamicSize += t.B.EncodedSize()
	dynamicSize += t.E.EncodedSize()
	dynamicSize += t.F.EncodedSize()
	dynamicSize += t.G.EncodedSize()

	return DummyCallStaticSize + dynamicSize
}

// EncodeTo encodes DummyCall to ABI bytes in the provided buffer
func (value DummyCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DummyCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field A: (string,uint256)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.A.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field B: (string,uint256,uint8)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.B.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field C: (uint256,uint8)
	if _, err := value.C.EncodeTo(buf[64:]); err != nil {
		return 0, err
	}

	// Field D: (uint64,uint64)
	if _, err := value.D.EncodeTo(buf[128:]); err != nil {
		return 0, err
	}

	// Field E: (bytes,uint64,uint64,bool,bool)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[192+24:192+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.E.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field F: (bytes,uint64)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[224+24:224+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.F.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field G: (string,string,(string,uint256)[],string[],string[])
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[256+24:256+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.G.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DummyCall to ABI bytes
func (value DummyCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DummyCall from ABI bytes in the provided buffer
func (t *DummyCall) Decode(data []byte) (int, error) {
	if len(data) < 288 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 288
	// Decode dynamic field A
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field A")
		}
		n, err = t.A.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field B
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field B")
		}
		n, err = t.B.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field C: (uint256,uint8)
	_, err = t.C.Decode(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode static field D: (uint64,uint64)
	_, err = t.D.Decode(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field E
	{
		offset := int(binary.BigEndian.Uint64(data[192+24 : 192+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field E")
		}
		n, err = t.E.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field F
	{
		offset := int(binary.BigEndian.Uint64(data[224+24 : 224+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field F")
		}
		n, err = t.F.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field G
	{
		offset := int(binary.BigEndian.Uint64(data[256+24 : 256+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field G")
		}
		n, err = t.G.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t DummyCall) GetMethodName() string {
	return "dummy"
}

// GetMethodID returns the function name
func (t DummyCall) GetMethodID() [4]byte {
	return DummySelector
}

// EncodeWithSelector encodes dummy arguments to ABI bytes including function selector
func (t DummyCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], DummySelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// DummyReturn represents the input arguments for dummy function
type DummyReturn struct {
	abi.EmptyTuple
}
