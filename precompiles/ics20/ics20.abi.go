// Code generated by go-abi. DO NOT EDIT.

package ics20

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	cmn "github.com/cosmos/evm/precompiles/common"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// denom(string)
	DenomSelector = [4]byte{0x5f, 0x1f, 0x98, 0xa2}
	// denomHash(string)
	DenomHashSelector = [4]byte{0xb5, 0xcb, 0x6e, 0x7d}
	// denoms((bytes,uint64,uint64,bool,bool))
	DenomsSelector = [4]byte{0xc0, 0xfa, 0xb1, 0x04}
	// transfer(string,string,string,uint256,address,string,(uint64,uint64),uint64,string)
	TransferSelector = [4]byte{0x63, 0x25, 0x35, 0xb9}
)

// Big endian integer versions of function selectors
const (
	DenomID     = 1595906210
	DenomHashID = 3050008189
	DenomsID    = 3237654788
	TransferID  = 1663382969
)

const DenomStaticSize = 64

var _ abi.Tuple = (*Denom)(nil)

// Denom represents an ABI tuple
type Denom struct {
	Base  string
	Trace []Hop
}

// EncodedSize returns the total encoded size of Denom
func (t Denom) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Base)
	dynamicSize += SizeHopSlice(t.Trace)

	return DenomStaticSize + dynamicSize
}

// EncodeTo encodes Denom to ABI bytes in the provided buffer
func (value Denom) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Base: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Base, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Trace: (string,string)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeHopSlice(value.Trace, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Denom to ABI bytes
func (value Denom) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Denom from ABI bytes in the provided buffer
func (t *Denom) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Base
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Base")
		}
		t.Base, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Trace
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Trace")
		}
		t.Trace, n, err = DecodeHopSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const HopStaticSize = 64

var _ abi.Tuple = (*Hop)(nil)

// Hop represents an ABI tuple
type Hop struct {
	PortId    string
	ChannelId string
}

// EncodedSize returns the total encoded size of Hop
func (t Hop) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.PortId)
	dynamicSize += abi.SizeString(t.ChannelId)

	return HopStaticSize + dynamicSize
}

// EncodeTo encodes Hop to ABI bytes in the provided buffer
func (value Hop) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := HopStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field PortId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.PortId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field ChannelId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.ChannelId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Hop to ABI bytes
func (value Hop) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Hop from ABI bytes in the provided buffer
func (t *Hop) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field PortId
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PortId")
		}
		t.PortId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field ChannelId
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field ChannelId")
		}
		t.ChannelId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// EncodeDenomSlice encodes (string,(string,string)[])[] to ABI bytes
func EncodeDenomSlice(value []Denom, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// EncodeHopSlice encodes (string,string)[] to ABI bytes
func EncodeHopSlice(value []Hop, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with dynamic types
	var offset int
	dynamicOffset := len(value) * 32
	for _, elem := range value {
		// Write offset for element
		offset += 32
		binary.BigEndian.PutUint64(buf[offset-8:offset], uint64(dynamicOffset))

		// Write element at dynamic region
		n, err := elem.EncodeTo(buf[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}

	return dynamicOffset + 32, nil
}

// SizeDenomSlice returns the encoded size of (string,(string,string)[])[]
func SizeDenomSlice(value []Denom) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// SizeHopSlice returns the encoded size of (string,string)[]
func SizeHopSlice(value []Hop) int {
	size := 32 + 32*len(value) // length + offset pointers for dynamic elements
	for _, elem := range value {
		size += elem.EncodedSize()
	}
	return size
}

// DecodeDenomSlice decodes (string,(string,string)[])[] from ABI bytes
func DecodeDenomSlice(data []byte) ([]Denom, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Denom, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

// DecodeHopSlice decodes (string,string)[] from ABI bytes
func DecodeHopSlice(data []byte) ([]Hop, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 32*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with dynamic types
	result := make([]Hop, length)
	dynamicOffset := length * 32
	for i := 0; i < length; i++ {
		offset += 32
		tmp := int(binary.BigEndian.Uint64(data[offset-8 : offset]))
		if dynamicOffset != tmp {
			return nil, 0, fmt.Errorf("invalid offset for slice element %d: expected %d, got %d", i, dynamicOffset, tmp)
		}
		n, err = result[i].Decode(data[dynamicOffset:])
		if err != nil {
			return nil, 0, err
		}
		dynamicOffset += n
	}
	return result, dynamicOffset + 32, nil
}

var _ abi.Method = (*DenomCall)(nil)

const DenomCallStaticSize = 32

var _ abi.Tuple = (*DenomCall)(nil)

// DenomCall represents an ABI tuple
type DenomCall struct {
	Hash string
}

// EncodedSize returns the total encoded size of DenomCall
func (t DenomCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Hash)

	return DenomCallStaticSize + dynamicSize
}

// EncodeTo encodes DenomCall to ABI bytes in the provided buffer
func (value DenomCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Hash: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Hash, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DenomCall to ABI bytes
func (value DenomCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DenomCall from ABI bytes in the provided buffer
func (t *DenomCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Hash
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Hash")
		}
		t.Hash, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t DenomCall) GetMethodName() string {
	return "denom"
}

// GetMethodID returns the function id
func (t DenomCall) GetMethodID() uint32 {
	return DenomID
}

// GetMethodSelector returns the function selector
func (t DenomCall) GetMethodSelector() [4]byte {
	return DenomSelector
}

// EncodeWithSelector encodes denom arguments to ABI bytes including function selector
func (t DenomCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], DenomSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewDenomCall constructs a new DenomCall
func NewDenomCall(
	hash string,
) DenomCall {
	return DenomCall{
		Hash: hash,
	}
}

const DenomReturnStaticSize = 32

var _ abi.Tuple = (*DenomReturn)(nil)

// DenomReturn represents an ABI tuple
type DenomReturn struct {
	Denom Denom
}

// EncodedSize returns the total encoded size of DenomReturn
func (t DenomReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.Denom.EncodedSize()

	return DenomReturnStaticSize + dynamicSize
}

// EncodeTo encodes DenomReturn to ABI bytes in the provided buffer
func (value DenomReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: (string,(string,string)[])
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.Denom.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DenomReturn to ABI bytes
func (value DenomReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DenomReturn from ABI bytes in the provided buffer
func (t *DenomReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		n, err = t.Denom.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*DenomHashCall)(nil)

const DenomHashCallStaticSize = 32

var _ abi.Tuple = (*DenomHashCall)(nil)

// DenomHashCall represents an ABI tuple
type DenomHashCall struct {
	Trace string
}

// EncodedSize returns the total encoded size of DenomHashCall
func (t DenomHashCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Trace)

	return DenomHashCallStaticSize + dynamicSize
}

// EncodeTo encodes DenomHashCall to ABI bytes in the provided buffer
func (value DenomHashCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomHashCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Trace: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Trace, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DenomHashCall to ABI bytes
func (value DenomHashCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DenomHashCall from ABI bytes in the provided buffer
func (t *DenomHashCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Trace
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Trace")
		}
		t.Trace, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t DenomHashCall) GetMethodName() string {
	return "denomHash"
}

// GetMethodID returns the function id
func (t DenomHashCall) GetMethodID() uint32 {
	return DenomHashID
}

// GetMethodSelector returns the function selector
func (t DenomHashCall) GetMethodSelector() [4]byte {
	return DenomHashSelector
}

// EncodeWithSelector encodes denomHash arguments to ABI bytes including function selector
func (t DenomHashCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], DenomHashSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewDenomHashCall constructs a new DenomHashCall
func NewDenomHashCall(
	trace string,
) DenomHashCall {
	return DenomHashCall{
		Trace: trace,
	}
}

const DenomHashReturnStaticSize = 32

var _ abi.Tuple = (*DenomHashReturn)(nil)

// DenomHashReturn represents an ABI tuple
type DenomHashReturn struct {
	Hash string
}

// EncodedSize returns the total encoded size of DenomHashReturn
func (t DenomHashReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Hash)

	return DenomHashReturnStaticSize + dynamicSize
}

// EncodeTo encodes DenomHashReturn to ABI bytes in the provided buffer
func (value DenomHashReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomHashReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Hash: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Hash, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DenomHashReturn to ABI bytes
func (value DenomHashReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DenomHashReturn from ABI bytes in the provided buffer
func (t *DenomHashReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Hash
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Hash")
		}
		t.Hash, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*DenomsCall)(nil)

const DenomsCallStaticSize = 32

var _ abi.Tuple = (*DenomsCall)(nil)

// DenomsCall represents an ABI tuple
type DenomsCall struct {
	PageRequest cmn.PageRequest
}

// EncodedSize returns the total encoded size of DenomsCall
func (t DenomsCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += t.PageRequest.EncodedSize()

	return DenomsCallStaticSize + dynamicSize
}

// EncodeTo encodes DenomsCall to ABI bytes in the provided buffer
func (value DenomsCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomsCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field PageRequest: (bytes,uint64,uint64,bool,bool)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.PageRequest.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DenomsCall to ABI bytes
func (value DenomsCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DenomsCall from ABI bytes in the provided buffer
func (t *DenomsCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field PageRequest
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PageRequest")
		}
		n, err = t.PageRequest.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t DenomsCall) GetMethodName() string {
	return "denoms"
}

// GetMethodID returns the function id
func (t DenomsCall) GetMethodID() uint32 {
	return DenomsID
}

// GetMethodSelector returns the function selector
func (t DenomsCall) GetMethodSelector() [4]byte {
	return DenomsSelector
}

// EncodeWithSelector encodes denoms arguments to ABI bytes including function selector
func (t DenomsCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], DenomsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewDenomsCall constructs a new DenomsCall
func NewDenomsCall(
	pageRequest cmn.PageRequest,
) DenomsCall {
	return DenomsCall{
		PageRequest: pageRequest,
	}
}

const DenomsReturnStaticSize = 64

var _ abi.Tuple = (*DenomsReturn)(nil)

// DenomsReturn represents an ABI tuple
type DenomsReturn struct {
	Denoms       []Denom
	PageResponse cmn.PageResponse
}

// EncodedSize returns the total encoded size of DenomsReturn
func (t DenomsReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeDenomSlice(t.Denoms)
	dynamicSize += t.PageResponse.EncodedSize()

	return DenomsReturnStaticSize + dynamicSize
}

// EncodeTo encodes DenomsReturn to ABI bytes in the provided buffer
func (value DenomsReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DenomsReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denoms: (string,(string,string)[])[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeDenomSlice(value.Denoms, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field PageResponse: (bytes,uint64)
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = value.PageResponse.EncodeTo(buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DenomsReturn to ABI bytes
func (value DenomsReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DenomsReturn from ABI bytes in the provided buffer
func (t *DenomsReturn) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Denoms
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denoms")
		}
		t.Denoms, n, err = DecodeDenomSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field PageResponse
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PageResponse")
		}
		n, err = t.PageResponse.Decode(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*TransferCall)(nil)

const TransferCallStaticSize = 320

var _ abi.Tuple = (*TransferCall)(nil)

// TransferCall represents an ABI tuple
type TransferCall struct {
	SourcePort       string
	SourceChannel    string
	Denom            string
	Amount           *big.Int
	Sender           common.Address
	Receiver         string
	TimeoutHeight    cmn.Height
	TimeoutTimestamp uint64
	Memo             string
}

// EncodedSize returns the total encoded size of TransferCall
func (t TransferCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.SourcePort)
	dynamicSize += abi.SizeString(t.SourceChannel)
	dynamicSize += abi.SizeString(t.Denom)
	dynamicSize += abi.SizeString(t.Receiver)
	dynamicSize += abi.SizeString(t.Memo)

	return TransferCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferCall to ABI bytes in the provided buffer
func (value TransferCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field SourcePort: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.SourcePort, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field SourceChannel: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.SourceChannel, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[96:]); err != nil {
		return 0, err
	}

	// Field Sender: address
	if _, err := abi.EncodeAddress(value.Sender, buf[128:]); err != nil {
		return 0, err
	}

	// Field Receiver: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[160+24:160+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Receiver, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field TimeoutHeight: (uint64,uint64)
	if _, err := value.TimeoutHeight.EncodeTo(buf[192:]); err != nil {
		return 0, err
	}

	// Field TimeoutTimestamp: uint64
	if _, err := abi.EncodeUint64(value.TimeoutTimestamp, buf[256:]); err != nil {
		return 0, err
	}

	// Field Memo: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[288+24:288+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Memo, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TransferCall to ABI bytes
func (value TransferCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferCall from ABI bytes in the provided buffer
func (t *TransferCall) Decode(data []byte) (int, error) {
	if len(data) < 320 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 320
	// Decode dynamic field SourcePort
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SourcePort")
		}
		t.SourcePort, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field SourceChannel
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SourceChannel")
		}
		t.SourceChannel, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode static field Sender: address
	t.Sender, _, err = abi.DecodeAddress(data[128:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Receiver
	{
		offset := int(binary.BigEndian.Uint64(data[160+24 : 160+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Receiver")
		}
		t.Receiver, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field TimeoutHeight: (uint64,uint64)
	_, err = t.TimeoutHeight.Decode(data[192:])
	if err != nil {
		return 0, err
	}
	// Decode static field TimeoutTimestamp: uint64
	t.TimeoutTimestamp, _, err = abi.DecodeUint64(data[256:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Memo
	{
		offset := int(binary.BigEndian.Uint64(data[288+24 : 288+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Memo")
		}
		t.Memo, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TransferCall) GetMethodName() string {
	return "transfer"
}

// GetMethodID returns the function id
func (t TransferCall) GetMethodID() uint32 {
	return TransferID
}

// GetMethodSelector returns the function selector
func (t TransferCall) GetMethodSelector() [4]byte {
	return TransferSelector
}

// EncodeWithSelector encodes transfer arguments to ABI bytes including function selector
func (t TransferCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTransferCall constructs a new TransferCall
func NewTransferCall(
	sourcePort string,
	sourceChannel string,
	denom string,
	amount *big.Int,
	sender common.Address,
	receiver string,
	timeoutHeight cmn.Height,
	timeoutTimestamp uint64,
	memo string,
) TransferCall {
	return TransferCall{
		SourcePort:       sourcePort,
		SourceChannel:    sourceChannel,
		Denom:            denom,
		Amount:           amount,
		Sender:           sender,
		Receiver:         receiver,
		TimeoutHeight:    timeoutHeight,
		TimeoutTimestamp: timeoutTimestamp,
		Memo:             memo,
	}
}

const TransferReturnStaticSize = 32

var _ abi.Tuple = (*TransferReturn)(nil)

// TransferReturn represents an ABI tuple
type TransferReturn struct {
	NextSequence uint64
}

// EncodedSize returns the total encoded size of TransferReturn
func (t TransferReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferReturn to ABI bytes in the provided buffer
func (value TransferReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferReturnStaticSize // Start dynamic data after static section
	// Field NextSequence: uint64
	if _, err := abi.EncodeUint64(value.NextSequence, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferReturn to ABI bytes
func (value TransferReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferReturn from ABI bytes in the provided buffer
func (t *TransferReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field NextSequence: uint64
	t.NextSequence, _, err = abi.DecodeUint64(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// Event signatures
var (
	// IBCTransfer(address,string,string,string,string,uint256,string)
	IBCTransferEventTopic = common.Hash{0xc0, 0x1e, 0xca, 0x5e, 0x74, 0x2f, 0xe6, 0x64, 0x1c, 0x4b, 0xe5, 0x01, 0xc2, 0xbe, 0xbf, 0x22, 0x44, 0x72, 0xf6, 0x91, 0x76, 0xa0, 0x55, 0x2e, 0x87, 0xe3, 0x01, 0x47, 0xa6, 0x41, 0x13, 0x03}
)

// IBCTransferEvent represents the IBCTransfer event
var _ abi.Event = (*IBCTransferEvent)(nil)

type IBCTransferEvent struct {
	IBCTransferEventIndexed
	IBCTransferEventData
}

// NewIBCTransferEvent constructs a new IBCTransfer event
func NewIBCTransferEvent(
	sender common.Address,
	receiver string,
	sourcePort string,
	sourceChannel string,
	denom string,
	amount *big.Int,
	memo string,
) IBCTransferEvent {
	return IBCTransferEvent{
		IBCTransferEventIndexed: IBCTransferEventIndexed{
			Sender:   sender,
			Receiver: receiver,
		},
		IBCTransferEventData: IBCTransferEventData{
			SourcePort:    sourcePort,
			SourceChannel: sourceChannel,
			Denom:         denom,
			Amount:        amount,
			Memo:          memo,
		},
	}
}

// GetEventName returns the event name
func (e IBCTransferEvent) GetEventName() string {
	return "IBCTransfer"
}

// GetEventID returns the event ID (topic)
func (e IBCTransferEvent) GetEventID() common.Hash {
	return IBCTransferEventTopic
}

// IBCTransfer represents an ABI event
type IBCTransferEventIndexed struct {
	Sender   common.Address
	Receiver string
}

// EncodeTopics encodes indexed fields of IBCTransfer event to topics
func (e IBCTransferEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, IBCTransferEventTopic)
	{
		// Sender
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.Sender, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	{
		// Receiver
		encodedSize := abi.SizeString(e.Receiver)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.Receiver, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of IBCTransfer event from topics, ignore hash topics
func (e *IBCTransferEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return fmt.Errorf("invalid number of topics for IBCTransfer event: expected 3, got %d", len(topics))
	}
	if topics[0] != IBCTransferEventTopic {
		return fmt.Errorf("invalid event topic for IBCTransfer event")
	}
	var err error
	e.Sender, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

const IBCTransferEventDataStaticSize = 160

var _ abi.Tuple = (*IBCTransferEventData)(nil)

// IBCTransferEventData represents an ABI tuple
type IBCTransferEventData struct {
	SourcePort    string
	SourceChannel string
	Denom         string
	Amount        *big.Int
	Memo          string
}

// EncodedSize returns the total encoded size of IBCTransferEventData
func (t IBCTransferEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.SourcePort)
	dynamicSize += abi.SizeString(t.SourceChannel)
	dynamicSize += abi.SizeString(t.Denom)
	dynamicSize += abi.SizeString(t.Memo)

	return IBCTransferEventDataStaticSize + dynamicSize
}

// EncodeTo encodes IBCTransferEventData to ABI bytes in the provided buffer
func (value IBCTransferEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := IBCTransferEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field SourcePort: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.SourcePort, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field SourceChannel: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.SourceChannel, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[96:]); err != nil {
		return 0, err
	}

	// Field Memo: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Memo, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes IBCTransferEventData to ABI bytes
func (value IBCTransferEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes IBCTransferEventData from ABI bytes in the provided buffer
func (t *IBCTransferEventData) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode dynamic field SourcePort
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SourcePort")
		}
		t.SourcePort, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field SourceChannel
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field SourceChannel")
		}
		t.SourceChannel, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[96:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Memo
	{
		offset := int(binary.BigEndian.Uint64(data[128+24 : 128+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Memo")
		}
		t.Memo, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
