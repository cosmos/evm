// Code generated by go-abi. DO NOT EDIT.

package bank

import (
	"encoding/binary"
	"errors"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balances(address)
	BalancesSelector = [4]byte{0x27, 0xe2, 0x35, 0xe3}
	// supplyOf(address)
	SupplyOfSelector = [4]byte{0x62, 0x40, 0x0e, 0x4c}
	// totalSupply()
	TotalSupplySelector = [4]byte{0x18, 0x16, 0x0d, 0xdd}
)

// Big endian integer versions of function selectors
const (
	BalancesID    = 669136355
	SupplyOfID    = 1648365132
	TotalSupplyID = 404098525
)

const BalanceStaticSize = 64

// Balance represents an ABI tuple
type Balance struct {
	ContractAddress common.Address
	Amount          *big.Int
}

// EncodedSize returns the total encoded size of Balance
func (t Balance) EncodedSize() int {
	dynamicSize := 0

	return BalanceStaticSize + dynamicSize
}

// EncodeTo encodes Balance to ABI bytes in the provided buffer
func (value Balance) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceStaticSize // Start dynamic data after static section
	// Field ContractAddress: address
	if _, err := abi.EncodeAddress(value.ContractAddress, buf[0:]); err != nil {
		return 0, err
	}

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Balance to ABI bytes
func (value Balance) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Balance from ABI bytes in the provided buffer
func (t *Balance) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field ContractAddress: address
	t.ContractAddress, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// EncodeBalanceSlice encodes (address,uint256)[] to ABI bytes
func EncodeBalanceSlice(value []Balance, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// SizeBalanceSlice returns the encoded size of (address,uint256)[]
func SizeBalanceSlice(value []Balance) int {
	size := 32 + 64*len(value) // length + static elements
	return size
}

// DecodeBalanceSlice decodes (address,uint256)[] from ABI bytes
func DecodeBalanceSlice(data []byte) ([]Balance, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 64*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]Balance, length)
	for i := 0; i < length; i++ {
		n, err = result[i].Decode(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

const BalancesCallStaticSize = 32

// BalancesCall represents an ABI tuple
type BalancesCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalancesCall
func (t BalancesCall) EncodedSize() int {
	dynamicSize := 0

	return BalancesCallStaticSize + dynamicSize
}

// EncodeTo encodes BalancesCall to ABI bytes in the provided buffer
func (value BalancesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalancesCallStaticSize // Start dynamic data after static section
	// Field Account: address
	if _, err := abi.EncodeAddress(value.Account, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalancesCall to ABI bytes
func (value BalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalancesCall from ABI bytes in the provided buffer
func (t *BalancesCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Account: address
	t.Account, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BalancesCall) GetMethodName() string {
	return "balances"
}

// GetMethodID returns the function name
func (t BalancesCall) GetMethodID() [4]byte {
	return BalancesSelector
}

// EncodeWithSelector encodes balances arguments to ABI bytes including function selector
func (t BalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const BalancesReturnStaticSize = 32

// BalancesReturn represents an ABI tuple
type BalancesReturn struct {
	Balances []Balance
}

// EncodedSize returns the total encoded size of BalancesReturn
func (t BalancesReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeBalanceSlice(t.Balances)

	return BalancesReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalancesReturn to ABI bytes in the provided buffer
func (value BalancesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalancesReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Balances: (address,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBalanceSlice(value.Balances, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes BalancesReturn to ABI bytes
func (value BalancesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalancesReturn from ABI bytes in the provided buffer
func (t *BalancesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Balances
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Balances")
		}
		t.Balances, n, err = DecodeBalanceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

const SupplyOfCallStaticSize = 32

// SupplyOfCall represents an ABI tuple
type SupplyOfCall struct {
	Erc20Address common.Address
}

// EncodedSize returns the total encoded size of SupplyOfCall
func (t SupplyOfCall) EncodedSize() int {
	dynamicSize := 0

	return SupplyOfCallStaticSize + dynamicSize
}

// EncodeTo encodes SupplyOfCall to ABI bytes in the provided buffer
func (value SupplyOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SupplyOfCallStaticSize // Start dynamic data after static section
	// Field Erc20Address: address
	if _, err := abi.EncodeAddress(value.Erc20Address, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SupplyOfCall to ABI bytes
func (value SupplyOfCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SupplyOfCall from ABI bytes in the provided buffer
func (t *SupplyOfCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Erc20Address: address
	t.Erc20Address, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SupplyOfCall) GetMethodName() string {
	return "supplyOf"
}

// GetMethodID returns the function name
func (t SupplyOfCall) GetMethodID() [4]byte {
	return SupplyOfSelector
}

// EncodeWithSelector encodes supplyOf arguments to ABI bytes including function selector
func (t SupplyOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SupplyOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const SupplyOfReturnStaticSize = 32

// SupplyOfReturn represents an ABI tuple
type SupplyOfReturn struct {
	TotalSupply *big.Int
}

// EncodedSize returns the total encoded size of SupplyOfReturn
func (t SupplyOfReturn) EncodedSize() int {
	dynamicSize := 0

	return SupplyOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes SupplyOfReturn to ABI bytes in the provided buffer
func (value SupplyOfReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SupplyOfReturnStaticSize // Start dynamic data after static section
	// Field TotalSupply: uint256
	if _, err := abi.EncodeUint256(value.TotalSupply, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SupplyOfReturn to ABI bytes
func (value SupplyOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SupplyOfReturn from ABI bytes in the provided buffer
func (t *SupplyOfReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field TotalSupply: uint256
	t.TotalSupply, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// TotalSupplyCall represents the input arguments for totalSupply function
type TotalSupplyCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t TotalSupplyCall) GetMethodName() string {
	return "totalSupply"
}

// GetMethodID returns the function name
func (t TotalSupplyCall) GetMethodID() [4]byte {
	return TotalSupplySelector
}

// EncodeWithSelector encodes totalSupply arguments to ABI bytes including function selector
func (t TotalSupplyCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TotalSupplySelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const TotalSupplyReturnStaticSize = 32

// TotalSupplyReturn represents an ABI tuple
type TotalSupplyReturn struct {
	TotalSupply []Balance
}

// EncodedSize returns the total encoded size of TotalSupplyReturn
func (t TotalSupplyReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeBalanceSlice(t.TotalSupply)

	return TotalSupplyReturnStaticSize + dynamicSize
}

// EncodeTo encodes TotalSupplyReturn to ABI bytes in the provided buffer
func (value TotalSupplyReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TotalSupplyReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field TotalSupply: (address,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBalanceSlice(value.TotalSupply, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TotalSupplyReturn to ABI bytes
func (value TotalSupplyReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TotalSupplyReturn from ABI bytes in the provided buffer
func (t *TotalSupplyReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field TotalSupply
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field TotalSupply")
		}
		t.TotalSupply, n, err = DecodeBalanceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
