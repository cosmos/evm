// Code generated by go-abi. DO NOT EDIT.

package bank

import (
	"encoding/binary"
	"errors"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// balanceOf(address,string)
	BalanceOfSelector = [4]byte{0xb9, 0xb0, 0x92, 0xc8}
	// balances(address)
	BalancesSelector = [4]byte{0x27, 0xe2, 0x35, 0xe3}
	// decimals(string)
	DecimalsSelector = [4]byte{0x3b, 0x2b, 0x32, 0x04}
	// erc20ctor(string,address)
	Erc20ctorSelector = [4]byte{0x11, 0x31, 0x32, 0x62}
	// name(string)
	NameSelector = [4]byte{0x5b, 0x43, 0xbc, 0x99}
	// supplyOf(address)
	SupplyOfSelector = [4]byte{0x62, 0x40, 0x0e, 0x4c}
	// symbol(string)
	SymbolSelector = [4]byte{0x41, 0xbb, 0x05, 0x59}
	// totalSupply()
	TotalSupplySelector = [4]byte{0x18, 0x16, 0x0d, 0xdd}
	// totalSupply(string)
	TotalSupply0Selector = [4]byte{0xc4, 0x15, 0xdb, 0x13}
	// transferFrom(address,address,uint256,string)
	TransferFromSelector = [4]byte{0x1a, 0xf7, 0x16, 0xba}
)

// Big endian integer versions of function selectors
const (
	BalanceOfID    = 3115356872
	BalancesID     = 669136355
	DecimalsID     = 992686596
	Erc20ctorID    = 288436834
	NameID         = 1531165849
	SupplyOfID     = 1648365132
	SymbolID       = 1102775641
	TotalSupplyID  = 404098525
	TotalSupply0ID = 3289766675
	TransferFromID = 452400826
)

const BalanceStaticSize = 64

var _ abi.Tuple = (*Balance)(nil)

// Balance represents an ABI tuple
type Balance struct {
	Contract common.Address
	Amount   *big.Int
}

// EncodedSize returns the total encoded size of Balance
func (t Balance) EncodedSize() int {
	dynamicSize := 0

	return BalanceStaticSize + dynamicSize
}

// EncodeTo encodes Balance to ABI bytes in the provided buffer
func (value Balance) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceStaticSize // Start dynamic data after static section
	// Field Contract: address
	if _, err := abi.EncodeAddress(value.Contract, buf[0:]); err != nil {
		return 0, err
	}

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Balance to ABI bytes
func (value Balance) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Balance from ABI bytes in the provided buffer
func (t *Balance) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field Contract: address
	t.Contract, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// EncodeBalanceSlice encodes (address,uint256)[] to ABI bytes
func EncodeBalanceSlice(value []Balance, buf []byte) (int, error) {
	// Encode length
	binary.BigEndian.PutUint64(buf[24:32], uint64(len(value)))
	buf = buf[32:]

	// Encode elements with static types
	var offset int
	for _, elem := range value {
		n, err := elem.EncodeTo(buf[offset:])
		if err != nil {
			return 0, err
		}
		offset += n
	}

	return offset + 32, nil
}

// SizeBalanceSlice returns the encoded size of (address,uint256)[]
func SizeBalanceSlice(value []Balance) int {
	size := 32 + 64*len(value) // length + static elements
	return size
}

// DecodeBalanceSlice decodes (address,uint256)[] from ABI bytes
func DecodeBalanceSlice(data []byte) ([]Balance, int, error) {
	// Decode length
	length := int(binary.BigEndian.Uint64(data[24:32]))
	if len(data) < 32 {
		return nil, 0, io.ErrUnexpectedEOF
	}
	data = data[32:]
	if len(data) < 64*length {
		return nil, 0, io.ErrUnexpectedEOF
	}
	var (
		n      int
		err    error
		offset int
	)
	// Decode elements with static types
	result := make([]Balance, length)
	for i := 0; i < length; i++ {
		n, err = result[i].Decode(data[offset:])
		if err != nil {
			return nil, 0, err
		}
		offset += n
	}
	return result, offset + 32, nil
}

var _ abi.Method = (*BalanceOfCall)(nil)

const BalanceOfCallStaticSize = 64

var _ abi.Tuple = (*BalanceOfCall)(nil)

// BalanceOfCall represents an ABI tuple
type BalanceOfCall struct {
	Account common.Address
	Denom   string
}

// EncodedSize returns the total encoded size of BalanceOfCall
func (t BalanceOfCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return BalanceOfCallStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfCall to ABI bytes in the provided buffer
func (value BalanceOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceOfCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Account: address
	if _, err := abi.EncodeAddress(value.Account, buf[0:]); err != nil {
		return 0, err
	}

	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes BalanceOfCall to ABI bytes
func (value BalanceOfCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfCall from ABI bytes in the provided buffer
func (t *BalanceOfCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Account: address
	t.Account, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BalanceOfCall) GetMethodName() string {
	return "balanceOf"
}

// GetMethodID returns the function id
func (t BalanceOfCall) GetMethodID() uint32 {
	return BalanceOfID
}

// GetMethodSelector returns the function selector
func (t BalanceOfCall) GetMethodSelector() [4]byte {
	return BalanceOfSelector
}

// EncodeWithSelector encodes balanceOf arguments to ABI bytes including function selector
func (t BalanceOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalanceOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewBalanceOfCall constructs a new BalanceOfCall
func NewBalanceOfCall(
	account common.Address,
	denom string,
) *BalanceOfCall {
	return &BalanceOfCall{
		Account: account,
		Denom:   denom,
	}
}

const BalanceOfReturnStaticSize = 32

var _ abi.Tuple = (*BalanceOfReturn)(nil)

// BalanceOfReturn represents an ABI tuple
type BalanceOfReturn struct {
	Balance *big.Int
}

// EncodedSize returns the total encoded size of BalanceOfReturn
func (t BalanceOfReturn) EncodedSize() int {
	dynamicSize := 0

	return BalanceOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalanceOfReturn to ABI bytes in the provided buffer
func (value BalanceOfReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalanceOfReturnStaticSize // Start dynamic data after static section
	// Field Balance: uint256
	if _, err := abi.EncodeUint256(value.Balance, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalanceOfReturn to ABI bytes
func (value BalanceOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalanceOfReturn from ABI bytes in the provided buffer
func (t *BalanceOfReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Balance: uint256
	t.Balance, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*BalancesCall)(nil)

const BalancesCallStaticSize = 32

var _ abi.Tuple = (*BalancesCall)(nil)

// BalancesCall represents an ABI tuple
type BalancesCall struct {
	Account common.Address
}

// EncodedSize returns the total encoded size of BalancesCall
func (t BalancesCall) EncodedSize() int {
	dynamicSize := 0

	return BalancesCallStaticSize + dynamicSize
}

// EncodeTo encodes BalancesCall to ABI bytes in the provided buffer
func (value BalancesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalancesCallStaticSize // Start dynamic data after static section
	// Field Account: address
	if _, err := abi.EncodeAddress(value.Account, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes BalancesCall to ABI bytes
func (value BalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalancesCall from ABI bytes in the provided buffer
func (t *BalancesCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Account: address
	t.Account, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t BalancesCall) GetMethodName() string {
	return "balances"
}

// GetMethodID returns the function id
func (t BalancesCall) GetMethodID() uint32 {
	return BalancesID
}

// GetMethodSelector returns the function selector
func (t BalancesCall) GetMethodSelector() [4]byte {
	return BalancesSelector
}

// EncodeWithSelector encodes balances arguments to ABI bytes including function selector
func (t BalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], BalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewBalancesCall constructs a new BalancesCall
func NewBalancesCall(
	account common.Address,
) *BalancesCall {
	return &BalancesCall{
		Account: account,
	}
}

const BalancesReturnStaticSize = 32

var _ abi.Tuple = (*BalancesReturn)(nil)

// BalancesReturn represents an ABI tuple
type BalancesReturn struct {
	Balances []Balance
}

// EncodedSize returns the total encoded size of BalancesReturn
func (t BalancesReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeBalanceSlice(t.Balances)

	return BalancesReturnStaticSize + dynamicSize
}

// EncodeTo encodes BalancesReturn to ABI bytes in the provided buffer
func (value BalancesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := BalancesReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Balances: (address,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBalanceSlice(value.Balances, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes BalancesReturn to ABI bytes
func (value BalancesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes BalancesReturn from ABI bytes in the provided buffer
func (t *BalancesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Balances
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Balances")
		}
		t.Balances, n, err = DecodeBalanceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*DecimalsCall)(nil)

const DecimalsCallStaticSize = 32

var _ abi.Tuple = (*DecimalsCall)(nil)

// DecimalsCall represents an ABI tuple
type DecimalsCall struct {
	Denom string
}

// EncodedSize returns the total encoded size of DecimalsCall
func (t DecimalsCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return DecimalsCallStaticSize + dynamicSize
}

// EncodeTo encodes DecimalsCall to ABI bytes in the provided buffer
func (value DecimalsCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DecimalsCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes DecimalsCall to ABI bytes
func (value DecimalsCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DecimalsCall from ABI bytes in the provided buffer
func (t *DecimalsCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t DecimalsCall) GetMethodName() string {
	return "decimals"
}

// GetMethodID returns the function id
func (t DecimalsCall) GetMethodID() uint32 {
	return DecimalsID
}

// GetMethodSelector returns the function selector
func (t DecimalsCall) GetMethodSelector() [4]byte {
	return DecimalsSelector
}

// EncodeWithSelector encodes decimals arguments to ABI bytes including function selector
func (t DecimalsCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], DecimalsSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewDecimalsCall constructs a new DecimalsCall
func NewDecimalsCall(
	denom string,
) *DecimalsCall {
	return &DecimalsCall{
		Denom: denom,
	}
}

const DecimalsReturnStaticSize = 32

var _ abi.Tuple = (*DecimalsReturn)(nil)

// DecimalsReturn represents an ABI tuple
type DecimalsReturn struct {
	Decimals uint8
}

// EncodedSize returns the total encoded size of DecimalsReturn
func (t DecimalsReturn) EncodedSize() int {
	dynamicSize := 0

	return DecimalsReturnStaticSize + dynamicSize
}

// EncodeTo encodes DecimalsReturn to ABI bytes in the provided buffer
func (value DecimalsReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := DecimalsReturnStaticSize // Start dynamic data after static section
	// Field Decimals: uint8
	if _, err := abi.EncodeUint8(value.Decimals, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes DecimalsReturn to ABI bytes
func (value DecimalsReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes DecimalsReturn from ABI bytes in the provided buffer
func (t *DecimalsReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Decimals: uint8
	t.Decimals, _, err = abi.DecodeUint8(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*Erc20ctorCall)(nil)

const Erc20ctorCallStaticSize = 64

var _ abi.Tuple = (*Erc20ctorCall)(nil)

// Erc20ctorCall represents an ABI tuple
type Erc20ctorCall struct {
	Denom string
	Bank  common.Address
}

// EncodedSize returns the total encoded size of Erc20ctorCall
func (t Erc20ctorCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return Erc20ctorCallStaticSize + dynamicSize
}

// EncodeTo encodes Erc20ctorCall to ABI bytes in the provided buffer
func (value Erc20ctorCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Erc20ctorCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Bank: address
	if _, err := abi.EncodeAddress(value.Bank, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Erc20ctorCall to ABI bytes
func (value Erc20ctorCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Erc20ctorCall from ABI bytes in the provided buffer
func (t *Erc20ctorCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Bank: address
	t.Bank, _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t Erc20ctorCall) GetMethodName() string {
	return "erc20ctor"
}

// GetMethodID returns the function id
func (t Erc20ctorCall) GetMethodID() uint32 {
	return Erc20ctorID
}

// GetMethodSelector returns the function selector
func (t Erc20ctorCall) GetMethodSelector() [4]byte {
	return Erc20ctorSelector
}

// EncodeWithSelector encodes erc20ctor arguments to ABI bytes including function selector
func (t Erc20ctorCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Erc20ctorSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewErc20ctorCall constructs a new Erc20ctorCall
func NewErc20ctorCall(
	denom string,
	bank common.Address,
) *Erc20ctorCall {
	return &Erc20ctorCall{
		Denom: denom,
		Bank:  bank,
	}
}

// Erc20ctorReturn represents the output arguments for erc20ctor function
type Erc20ctorReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*NameCall)(nil)

const NameCallStaticSize = 32

var _ abi.Tuple = (*NameCall)(nil)

// NameCall represents an ABI tuple
type NameCall struct {
	Denom string
}

// EncodedSize returns the total encoded size of NameCall
func (t NameCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return NameCallStaticSize + dynamicSize
}

// EncodeTo encodes NameCall to ABI bytes in the provided buffer
func (value NameCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := NameCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes NameCall to ABI bytes
func (value NameCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes NameCall from ABI bytes in the provided buffer
func (t *NameCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t NameCall) GetMethodName() string {
	return "name"
}

// GetMethodID returns the function id
func (t NameCall) GetMethodID() uint32 {
	return NameID
}

// GetMethodSelector returns the function selector
func (t NameCall) GetMethodSelector() [4]byte {
	return NameSelector
}

// EncodeWithSelector encodes name arguments to ABI bytes including function selector
func (t NameCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], NameSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewNameCall constructs a new NameCall
func NewNameCall(
	denom string,
) *NameCall {
	return &NameCall{
		Denom: denom,
	}
}

const NameReturnStaticSize = 32

var _ abi.Tuple = (*NameReturn)(nil)

// NameReturn represents an ABI tuple
type NameReturn struct {
	Name string
}

// EncodedSize returns the total encoded size of NameReturn
func (t NameReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Name)

	return NameReturnStaticSize + dynamicSize
}

// EncodeTo encodes NameReturn to ABI bytes in the provided buffer
func (value NameReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := NameReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Name: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Name, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes NameReturn to ABI bytes
func (value NameReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes NameReturn from ABI bytes in the provided buffer
func (t *NameReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Name
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Name")
		}
		t.Name, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*SupplyOfCall)(nil)

const SupplyOfCallStaticSize = 32

var _ abi.Tuple = (*SupplyOfCall)(nil)

// SupplyOfCall represents an ABI tuple
type SupplyOfCall struct {
	Contract common.Address
}

// EncodedSize returns the total encoded size of SupplyOfCall
func (t SupplyOfCall) EncodedSize() int {
	dynamicSize := 0

	return SupplyOfCallStaticSize + dynamicSize
}

// EncodeTo encodes SupplyOfCall to ABI bytes in the provided buffer
func (value SupplyOfCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SupplyOfCallStaticSize // Start dynamic data after static section
	// Field Contract: address
	if _, err := abi.EncodeAddress(value.Contract, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SupplyOfCall to ABI bytes
func (value SupplyOfCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SupplyOfCall from ABI bytes in the provided buffer
func (t *SupplyOfCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Contract: address
	t.Contract, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SupplyOfCall) GetMethodName() string {
	return "supplyOf"
}

// GetMethodID returns the function id
func (t SupplyOfCall) GetMethodID() uint32 {
	return SupplyOfID
}

// GetMethodSelector returns the function selector
func (t SupplyOfCall) GetMethodSelector() [4]byte {
	return SupplyOfSelector
}

// EncodeWithSelector encodes supplyOf arguments to ABI bytes including function selector
func (t SupplyOfCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SupplyOfSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewSupplyOfCall constructs a new SupplyOfCall
func NewSupplyOfCall(
	contract common.Address,
) *SupplyOfCall {
	return &SupplyOfCall{
		Contract: contract,
	}
}

const SupplyOfReturnStaticSize = 32

var _ abi.Tuple = (*SupplyOfReturn)(nil)

// SupplyOfReturn represents an ABI tuple
type SupplyOfReturn struct {
	TotalSupply *big.Int
}

// EncodedSize returns the total encoded size of SupplyOfReturn
func (t SupplyOfReturn) EncodedSize() int {
	dynamicSize := 0

	return SupplyOfReturnStaticSize + dynamicSize
}

// EncodeTo encodes SupplyOfReturn to ABI bytes in the provided buffer
func (value SupplyOfReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SupplyOfReturnStaticSize // Start dynamic data after static section
	// Field TotalSupply: uint256
	if _, err := abi.EncodeUint256(value.TotalSupply, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes SupplyOfReturn to ABI bytes
func (value SupplyOfReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SupplyOfReturn from ABI bytes in the provided buffer
func (t *SupplyOfReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field TotalSupply: uint256
	t.TotalSupply, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*SymbolCall)(nil)

const SymbolCallStaticSize = 32

var _ abi.Tuple = (*SymbolCall)(nil)

// SymbolCall represents an ABI tuple
type SymbolCall struct {
	Denom string
}

// EncodedSize returns the total encoded size of SymbolCall
func (t SymbolCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return SymbolCallStaticSize + dynamicSize
}

// EncodeTo encodes SymbolCall to ABI bytes in the provided buffer
func (value SymbolCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SymbolCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes SymbolCall to ABI bytes
func (value SymbolCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SymbolCall from ABI bytes in the provided buffer
func (t *SymbolCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t SymbolCall) GetMethodName() string {
	return "symbol"
}

// GetMethodID returns the function id
func (t SymbolCall) GetMethodID() uint32 {
	return SymbolID
}

// GetMethodSelector returns the function selector
func (t SymbolCall) GetMethodSelector() [4]byte {
	return SymbolSelector
}

// EncodeWithSelector encodes symbol arguments to ABI bytes including function selector
func (t SymbolCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], SymbolSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewSymbolCall constructs a new SymbolCall
func NewSymbolCall(
	denom string,
) *SymbolCall {
	return &SymbolCall{
		Denom: denom,
	}
}

const SymbolReturnStaticSize = 32

var _ abi.Tuple = (*SymbolReturn)(nil)

// SymbolReturn represents an ABI tuple
type SymbolReturn struct {
	Symbol string
}

// EncodedSize returns the total encoded size of SymbolReturn
func (t SymbolReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Symbol)

	return SymbolReturnStaticSize + dynamicSize
}

// EncodeTo encodes SymbolReturn to ABI bytes in the provided buffer
func (value SymbolReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := SymbolReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Symbol: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Symbol, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes SymbolReturn to ABI bytes
func (value SymbolReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes SymbolReturn from ABI bytes in the provided buffer
func (t *SymbolReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Symbol
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Symbol")
		}
		t.Symbol, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*TotalSupplyCall)(nil)

// TotalSupplyCall represents the input arguments for totalSupply function
type TotalSupplyCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t TotalSupplyCall) GetMethodName() string {
	return "totalSupply"
}

// GetMethodID returns the function id
func (t TotalSupplyCall) GetMethodID() uint32 {
	return TotalSupplyID
}

// GetMethodSelector returns the function selector
func (t TotalSupplyCall) GetMethodSelector() [4]byte {
	return TotalSupplySelector
}

// EncodeWithSelector encodes totalSupply arguments to ABI bytes including function selector
func (t TotalSupplyCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TotalSupplySelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTotalSupplyCall constructs a new TotalSupplyCall
func NewTotalSupplyCall() *TotalSupplyCall {
	return &TotalSupplyCall{}
}

const TotalSupplyReturnStaticSize = 32

var _ abi.Tuple = (*TotalSupplyReturn)(nil)

// TotalSupplyReturn represents an ABI tuple
type TotalSupplyReturn struct {
	TotalSupply []Balance
}

// EncodedSize returns the total encoded size of TotalSupplyReturn
func (t TotalSupplyReturn) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += SizeBalanceSlice(t.TotalSupply)

	return TotalSupplyReturnStaticSize + dynamicSize
}

// EncodeTo encodes TotalSupplyReturn to ABI bytes in the provided buffer
func (value TotalSupplyReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TotalSupplyReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field TotalSupply: (address,uint256)[]
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = EncodeBalanceSlice(value.TotalSupply, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TotalSupplyReturn to ABI bytes
func (value TotalSupplyReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TotalSupplyReturn from ABI bytes in the provided buffer
func (t *TotalSupplyReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field TotalSupply
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field TotalSupply")
		}
		t.TotalSupply, n, err = DecodeBalanceSlice(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*TotalSupply0Call)(nil)

const TotalSupply0CallStaticSize = 32

var _ abi.Tuple = (*TotalSupply0Call)(nil)

// TotalSupply0Call represents an ABI tuple
type TotalSupply0Call struct {
	Denom string
}

// EncodedSize returns the total encoded size of TotalSupply0Call
func (t TotalSupply0Call) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return TotalSupply0CallStaticSize + dynamicSize
}

// EncodeTo encodes TotalSupply0Call to ABI bytes in the provided buffer
func (value TotalSupply0Call) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TotalSupply0CallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TotalSupply0Call to ABI bytes
func (value TotalSupply0Call) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TotalSupply0Call from ABI bytes in the provided buffer
func (t *TotalSupply0Call) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TotalSupply0Call) GetMethodName() string {
	return "totalSupply0"
}

// GetMethodID returns the function id
func (t TotalSupply0Call) GetMethodID() uint32 {
	return TotalSupply0ID
}

// GetMethodSelector returns the function selector
func (t TotalSupply0Call) GetMethodSelector() [4]byte {
	return TotalSupply0Selector
}

// EncodeWithSelector encodes totalSupply0 arguments to ABI bytes including function selector
func (t TotalSupply0Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TotalSupply0Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTotalSupply0Call constructs a new TotalSupply0Call
func NewTotalSupply0Call(
	denom string,
) *TotalSupply0Call {
	return &TotalSupply0Call{
		Denom: denom,
	}
}

const TotalSupply0ReturnStaticSize = 32

var _ abi.Tuple = (*TotalSupply0Return)(nil)

// TotalSupply0Return represents an ABI tuple
type TotalSupply0Return struct {
	Supply *big.Int
}

// EncodedSize returns the total encoded size of TotalSupply0Return
func (t TotalSupply0Return) EncodedSize() int {
	dynamicSize := 0

	return TotalSupply0ReturnStaticSize + dynamicSize
}

// EncodeTo encodes TotalSupply0Return to ABI bytes in the provided buffer
func (value TotalSupply0Return) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TotalSupply0ReturnStaticSize // Start dynamic data after static section
	// Field Supply: uint256
	if _, err := abi.EncodeUint256(value.Supply, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TotalSupply0Return to ABI bytes
func (value TotalSupply0Return) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TotalSupply0Return from ABI bytes in the provided buffer
func (t *TotalSupply0Return) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Supply: uint256
	t.Supply, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*TransferFromCall)(nil)

const TransferFromCallStaticSize = 128

var _ abi.Tuple = (*TransferFromCall)(nil)

// TransferFromCall represents an ABI tuple
type TransferFromCall struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Denom string
}

// EncodedSize returns the total encoded size of TransferFromCall
func (t TransferFromCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Denom)

	return TransferFromCallStaticSize + dynamicSize
}

// EncodeTo encodes TransferFromCall to ABI bytes in the provided buffer
func (value TransferFromCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferFromCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field From: address
	if _, err := abi.EncodeAddress(value.From, buf[0:]); err != nil {
		return 0, err
	}

	// Field To: address
	if _, err := abi.EncodeAddress(value.To, buf[32:]); err != nil {
		return 0, err
	}

	// Field Value: uint256
	if _, err := abi.EncodeUint256(value.Value, buf[64:]); err != nil {
		return 0, err
	}

	// Field Denom: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Denom, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes TransferFromCall to ABI bytes
func (value TransferFromCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferFromCall from ABI bytes in the provided buffer
func (t *TransferFromCall) Decode(data []byte) (int, error) {
	if len(data) < 128 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 128
	// Decode static field From: address
	t.From, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field To: address
	t.To, _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return 0, err
	}
	// Decode static field Value: uint256
	t.Value, _, err = abi.DecodeUint256(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Denom
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Denom")
		}
		t.Denom, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t TransferFromCall) GetMethodName() string {
	return "transferFrom"
}

// GetMethodID returns the function id
func (t TransferFromCall) GetMethodID() uint32 {
	return TransferFromID
}

// GetMethodSelector returns the function selector
func (t TransferFromCall) GetMethodSelector() [4]byte {
	return TransferFromSelector
}

// EncodeWithSelector encodes transferFrom arguments to ABI bytes including function selector
func (t TransferFromCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], TransferFromSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewTransferFromCall constructs a new TransferFromCall
func NewTransferFromCall(
	from common.Address,
	to common.Address,
	value *big.Int,
	denom string,
) *TransferFromCall {
	return &TransferFromCall{
		From:  from,
		To:    to,
		Value: value,
		Denom: denom,
	}
}

const TransferFromReturnStaticSize = 32

var _ abi.Tuple = (*TransferFromReturn)(nil)

// TransferFromReturn represents an ABI tuple
type TransferFromReturn struct {
	Field1 bool
}

// EncodedSize returns the total encoded size of TransferFromReturn
func (t TransferFromReturn) EncodedSize() int {
	dynamicSize := 0

	return TransferFromReturnStaticSize + dynamicSize
}

// EncodeTo encodes TransferFromReturn to ABI bytes in the provided buffer
func (value TransferFromReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TransferFromReturnStaticSize // Start dynamic data after static section
	// Field Field1: bool
	if _, err := abi.EncodeBool(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TransferFromReturn to ABI bytes
func (value TransferFromReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TransferFromReturn from ABI bytes in the provided buffer
func (t *TransferFromReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: bool
	t.Field1, _, err = abi.DecodeBool(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}
