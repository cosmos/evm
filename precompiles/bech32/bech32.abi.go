// Code generated by go-abi. DO NOT EDIT.

package bech32

import (
	"encoding/binary"
	"errors"
	"io"

	"github.com/ethereum/go-ethereum/common"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// bech32ToHex(string)
	Bech32ToHexSelector = [4]byte{0xe6, 0xdf, 0x46, 0x1e}
	// hexToBech32(address,string)
	HexToBech32Selector = [4]byte{0xf9, 0x58, 0xa9, 0x8c}
)

// Big endian integer versions of function selectors
const (
	Bech32ToHexID = 3873392158
	HexToBech32ID = 4183337356
)

const Bech32ToHexCallStaticSize = 32

// Bech32ToHexCall represents an ABI tuple
type Bech32ToHexCall struct {
	Bech32Address string
}

// EncodedSize returns the total encoded size of Bech32ToHexCall
func (t Bech32ToHexCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Bech32Address)

	return Bech32ToHexCallStaticSize + dynamicSize
}

// EncodeTo encodes Bech32ToHexCall to ABI bytes in the provided buffer
func (value Bech32ToHexCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Bech32ToHexCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Bech32Address: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Bech32Address, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes Bech32ToHexCall to ABI bytes
func (value Bech32ToHexCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Bech32ToHexCall from ABI bytes in the provided buffer
func (t *Bech32ToHexCall) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Bech32Address
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Bech32Address")
		}
		t.Bech32Address, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t Bech32ToHexCall) GetMethodName() string {
	return "bech32ToHex"
}

// GetMethodID returns the function name
func (t Bech32ToHexCall) GetMethodID() [4]byte {
	return Bech32ToHexSelector
}

// EncodeWithSelector encodes bech32ToHex arguments to ABI bytes including function selector
func (t Bech32ToHexCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], Bech32ToHexSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const Bech32ToHexReturnStaticSize = 32

// Bech32ToHexReturn represents an ABI tuple
type Bech32ToHexReturn struct {
	Addr common.Address
}

// EncodedSize returns the total encoded size of Bech32ToHexReturn
func (t Bech32ToHexReturn) EncodedSize() int {
	dynamicSize := 0

	return Bech32ToHexReturnStaticSize + dynamicSize
}

// EncodeTo encodes Bech32ToHexReturn to ABI bytes in the provided buffer
func (value Bech32ToHexReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := Bech32ToHexReturnStaticSize // Start dynamic data after static section
	// Field Addr: address
	if _, err := abi.EncodeAddress(value.Addr, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes Bech32ToHexReturn to ABI bytes
func (value Bech32ToHexReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes Bech32ToHexReturn from ABI bytes in the provided buffer
func (t *Bech32ToHexReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Addr: address
	t.Addr, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

const HexToBech32CallStaticSize = 64

// HexToBech32Call represents an ABI tuple
type HexToBech32Call struct {
	Addr   common.Address
	Prefix string
}

// EncodedSize returns the total encoded size of HexToBech32Call
func (t HexToBech32Call) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Prefix)

	return HexToBech32CallStaticSize + dynamicSize
}

// EncodeTo encodes HexToBech32Call to ABI bytes in the provided buffer
func (value HexToBech32Call) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := HexToBech32CallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Addr: address
	if _, err := abi.EncodeAddress(value.Addr, buf[0:]); err != nil {
		return 0, err
	}

	// Field Prefix: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Prefix, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes HexToBech32Call to ABI bytes
func (value HexToBech32Call) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes HexToBech32Call from ABI bytes in the provided buffer
func (t *HexToBech32Call) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Addr: address
	t.Addr, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Prefix
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Prefix")
		}
		t.Prefix, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t HexToBech32Call) GetMethodName() string {
	return "hexToBech32"
}

// GetMethodID returns the function name
func (t HexToBech32Call) GetMethodID() [4]byte {
	return HexToBech32Selector
}

// EncodeWithSelector encodes hexToBech32 arguments to ABI bytes including function selector
func (t HexToBech32Call) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], HexToBech32Selector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

const HexToBech32ReturnStaticSize = 32

// HexToBech32Return represents an ABI tuple
type HexToBech32Return struct {
	Bech32Address string
}

// EncodedSize returns the total encoded size of HexToBech32Return
func (t HexToBech32Return) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.Bech32Address)

	return HexToBech32ReturnStaticSize + dynamicSize
}

// EncodeTo encodes HexToBech32Return to ABI bytes in the provided buffer
func (value HexToBech32Return) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := HexToBech32ReturnStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Bech32Address: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.Bech32Address, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes HexToBech32Return to ABI bytes
func (value HexToBech32Return) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes HexToBech32Return from ABI bytes in the provided buffer
func (t *HexToBech32Return) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 32
	// Decode dynamic field Bech32Address
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Bech32Address")
		}
		t.Bech32Address, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}
