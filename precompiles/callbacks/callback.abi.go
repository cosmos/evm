// Code generated by go-abi. DO NOT EDIT.

package callbacks

import (
	"encoding/binary"
	"errors"
	"io"

	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// onPacketAcknowledgement(string,string,uint64,bytes,bytes)
	OnPacketAcknowledgementSelector = [4]byte{0x39, 0xb4, 0x07, 0x3a}
	// onPacketTimeout(string,string,uint64,bytes)
	OnPacketTimeoutSelector = [4]byte{0x1f, 0x8e, 0xe6, 0x03}
)

// Big endian integer versions of function selectors
const (
	OnPacketAcknowledgementID = 968099642
	OnPacketTimeoutID         = 529458691
)

var _ abi.Method = (*OnPacketAcknowledgementCall)(nil)

const OnPacketAcknowledgementCallStaticSize = 160

var _ abi.Tuple = (*OnPacketAcknowledgementCall)(nil)

// OnPacketAcknowledgementCall represents an ABI tuple
type OnPacketAcknowledgementCall struct {
	ChannelId       string
	PortId          string
	Sequence        uint64
	Data            []byte
	Acknowledgement []byte
}

// EncodedSize returns the total encoded size of OnPacketAcknowledgementCall
func (t OnPacketAcknowledgementCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.ChannelId)
	dynamicSize += abi.SizeString(t.PortId)
	dynamicSize += abi.SizeBytes(t.Data)
	dynamicSize += abi.SizeBytes(t.Acknowledgement)

	return OnPacketAcknowledgementCallStaticSize + dynamicSize
}

// EncodeTo encodes OnPacketAcknowledgementCall to ABI bytes in the provided buffer
func (value OnPacketAcknowledgementCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := OnPacketAcknowledgementCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field ChannelId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.ChannelId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field PortId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.PortId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Sequence: uint64
	if _, err := abi.EncodeUint64(value.Sequence, buf[64:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Acknowledgement: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Acknowledgement, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes OnPacketAcknowledgementCall to ABI bytes
func (value OnPacketAcknowledgementCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes OnPacketAcknowledgementCall from ABI bytes in the provided buffer
func (t *OnPacketAcknowledgementCall) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode dynamic field ChannelId
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field ChannelId")
		}
		t.ChannelId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field PortId
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PortId")
		}
		t.PortId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Sequence: uint64
	t.Sequence, _, err = abi.DecodeUint64(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Acknowledgement
	{
		offset := int(binary.BigEndian.Uint64(data[128+24 : 128+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Acknowledgement")
		}
		t.Acknowledgement, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t OnPacketAcknowledgementCall) GetMethodName() string {
	return "onPacketAcknowledgement"
}

// GetMethodID returns the function id
func (t OnPacketAcknowledgementCall) GetMethodID() uint32 {
	return OnPacketAcknowledgementID
}

// GetMethodSelector returns the function selector
func (t OnPacketAcknowledgementCall) GetMethodSelector() [4]byte {
	return OnPacketAcknowledgementSelector
}

// EncodeWithSelector encodes onPacketAcknowledgement arguments to ABI bytes including function selector
func (t OnPacketAcknowledgementCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], OnPacketAcknowledgementSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewOnPacketAcknowledgementCall constructs a new OnPacketAcknowledgementCall
func NewOnPacketAcknowledgementCall(
	channelId string,
	portId string,
	sequence uint64,
	data []byte,
	acknowledgement []byte,
) *OnPacketAcknowledgementCall {
	return &OnPacketAcknowledgementCall{
		ChannelId:       channelId,
		PortId:          portId,
		Sequence:        sequence,
		Data:            data,
		Acknowledgement: acknowledgement,
	}
}

// OnPacketAcknowledgementReturn represents the output arguments for onPacketAcknowledgement function
type OnPacketAcknowledgementReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*OnPacketTimeoutCall)(nil)

const OnPacketTimeoutCallStaticSize = 128

var _ abi.Tuple = (*OnPacketTimeoutCall)(nil)

// OnPacketTimeoutCall represents an ABI tuple
type OnPacketTimeoutCall struct {
	ChannelId string
	PortId    string
	Sequence  uint64
	Data      []byte
}

// EncodedSize returns the total encoded size of OnPacketTimeoutCall
func (t OnPacketTimeoutCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.ChannelId)
	dynamicSize += abi.SizeString(t.PortId)
	dynamicSize += abi.SizeBytes(t.Data)

	return OnPacketTimeoutCallStaticSize + dynamicSize
}

// EncodeTo encodes OnPacketTimeoutCall to ABI bytes in the provided buffer
func (value OnPacketTimeoutCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := OnPacketTimeoutCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field ChannelId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.ChannelId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field PortId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.PortId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Sequence: uint64
	if _, err := abi.EncodeUint64(value.Sequence, buf[64:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes OnPacketTimeoutCall to ABI bytes
func (value OnPacketTimeoutCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes OnPacketTimeoutCall from ABI bytes in the provided buffer
func (t *OnPacketTimeoutCall) Decode(data []byte) (int, error) {
	if len(data) < 128 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 128
	// Decode dynamic field ChannelId
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field ChannelId")
		}
		t.ChannelId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field PortId
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PortId")
		}
		t.PortId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Sequence: uint64
	t.Sequence, _, err = abi.DecodeUint64(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t OnPacketTimeoutCall) GetMethodName() string {
	return "onPacketTimeout"
}

// GetMethodID returns the function id
func (t OnPacketTimeoutCall) GetMethodID() uint32 {
	return OnPacketTimeoutID
}

// GetMethodSelector returns the function selector
func (t OnPacketTimeoutCall) GetMethodSelector() [4]byte {
	return OnPacketTimeoutSelector
}

// EncodeWithSelector encodes onPacketTimeout arguments to ABI bytes including function selector
func (t OnPacketTimeoutCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], OnPacketTimeoutSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewOnPacketTimeoutCall constructs a new OnPacketTimeoutCall
func NewOnPacketTimeoutCall(
	channelId string,
	portId string,
	sequence uint64,
	data []byte,
) *OnPacketTimeoutCall {
	return &OnPacketTimeoutCall{
		ChannelId: channelId,
		PortId:    portId,
		Sequence:  sequence,
		Data:      data,
	}
}

// OnPacketTimeoutReturn represents the output arguments for onPacketTimeout function
type OnPacketTimeoutReturn struct {
	abi.EmptyTuple
}
