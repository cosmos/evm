// Code generated by go-abi. DO NOT EDIT.

package testutil

import (
	"encoding/binary"
	"errors"
	"fmt"
	"io"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/yihuang/go-abi"
)

// Function selectors
var (
	// add(address,uint256)
	AddSelector = [4]byte{0xf5, 0xd8, 0x2b, 0x6b}
	// counter()
	CounterSelector = [4]byte{0x61, 0xbc, 0x22, 0x1a}
	// getCounter()
	GetCounterSelector = [4]byte{0x8a, 0xda, 0x06, 0x6e}
	// getTokenBalance(address,address)
	GetTokenBalanceSelector = [4]byte{0xc4, 0x89, 0x74, 0x4b}
	// onPacketAcknowledgement(string,string,uint64,bytes,bytes)
	OnPacketAcknowledgementSelector = [4]byte{0x39, 0xb4, 0x07, 0x3a}
	// onPacketTimeout(string,string,uint64,bytes)
	OnPacketTimeoutSelector = [4]byte{0x1f, 0x8e, 0xe6, 0x03}
	// resetCounter()
	ResetCounterSelector = [4]byte{0xdb, 0xdf, 0x7f, 0xce}
	// userTokenBalances(address,address)
	UserTokenBalancesSelector = [4]byte{0x45, 0xf2, 0xd1, 0x05}
)

// Big endian integer versions of function selectors
const (
	AddID                     = 4124584811
	CounterID                 = 1639719450
	GetCounterID              = 2329544302
	GetTokenBalanceID         = 3297342539
	OnPacketAcknowledgementID = 968099642
	OnPacketTimeoutID         = 529458691
	ResetCounterID            = 3688857550
	UserTokenBalancesID       = 1173541125
)

var _ abi.Method = (*AddCall)(nil)

const AddCallStaticSize = 64

var _ abi.Tuple = (*AddCall)(nil)

// AddCall represents an ABI tuple
type AddCall struct {
	Token  common.Address
	Amount *big.Int
}

// EncodedSize returns the total encoded size of AddCall
func (t AddCall) EncodedSize() int {
	dynamicSize := 0

	return AddCallStaticSize + dynamicSize
}

// EncodeTo encodes AddCall to ABI bytes in the provided buffer
func (value AddCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := AddCallStaticSize // Start dynamic data after static section
	// Field Token: address
	if _, err := abi.EncodeAddress(value.Token, buf[0:]); err != nil {
		return 0, err
	}

	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes AddCall to ABI bytes
func (value AddCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes AddCall from ABI bytes in the provided buffer
func (t *AddCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field Token: address
	t.Token, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t AddCall) GetMethodName() string {
	return "add"
}

// GetMethodID returns the function id
func (t AddCall) GetMethodID() uint32 {
	return AddID
}

// GetMethodSelector returns the function selector
func (t AddCall) GetMethodSelector() [4]byte {
	return AddSelector
}

// EncodeWithSelector encodes add arguments to ABI bytes including function selector
func (t AddCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], AddSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewAddCall constructs a new AddCall
func NewAddCall(
	token common.Address,
	amount *big.Int,
) *AddCall {
	return &AddCall{
		Token:  token,
		Amount: amount,
	}
}

// AddReturn represents the output arguments for add function
type AddReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*CounterCall)(nil)

// CounterCall represents the input arguments for counter function
type CounterCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t CounterCall) GetMethodName() string {
	return "counter"
}

// GetMethodID returns the function id
func (t CounterCall) GetMethodID() uint32 {
	return CounterID
}

// GetMethodSelector returns the function selector
func (t CounterCall) GetMethodSelector() [4]byte {
	return CounterSelector
}

// EncodeWithSelector encodes counter arguments to ABI bytes including function selector
func (t CounterCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], CounterSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewCounterCall constructs a new CounterCall
func NewCounterCall() *CounterCall {
	return &CounterCall{}
}

const CounterReturnStaticSize = 32

var _ abi.Tuple = (*CounterReturn)(nil)

// CounterReturn represents an ABI tuple
type CounterReturn struct {
	Field1 *big.Int
}

// EncodedSize returns the total encoded size of CounterReturn
func (t CounterReturn) EncodedSize() int {
	dynamicSize := 0

	return CounterReturnStaticSize + dynamicSize
}

// EncodeTo encodes CounterReturn to ABI bytes in the provided buffer
func (value CounterReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := CounterReturnStaticSize // Start dynamic data after static section
	// Field Field1: int256
	if _, err := abi.EncodeInt256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes CounterReturn to ABI bytes
func (value CounterReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes CounterReturn from ABI bytes in the provided buffer
func (t *CounterReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: int256
	t.Field1, _, err = abi.DecodeInt256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*GetCounterCall)(nil)

// GetCounterCall represents the input arguments for getCounter function
type GetCounterCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t GetCounterCall) GetMethodName() string {
	return "getCounter"
}

// GetMethodID returns the function id
func (t GetCounterCall) GetMethodID() uint32 {
	return GetCounterID
}

// GetMethodSelector returns the function selector
func (t GetCounterCall) GetMethodSelector() [4]byte {
	return GetCounterSelector
}

// EncodeWithSelector encodes getCounter arguments to ABI bytes including function selector
func (t GetCounterCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetCounterSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewGetCounterCall constructs a new GetCounterCall
func NewGetCounterCall() *GetCounterCall {
	return &GetCounterCall{}
}

const GetCounterReturnStaticSize = 32

var _ abi.Tuple = (*GetCounterReturn)(nil)

// GetCounterReturn represents an ABI tuple
type GetCounterReturn struct {
	Field1 *big.Int
}

// EncodedSize returns the total encoded size of GetCounterReturn
func (t GetCounterReturn) EncodedSize() int {
	dynamicSize := 0

	return GetCounterReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetCounterReturn to ABI bytes in the provided buffer
func (value GetCounterReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetCounterReturnStaticSize // Start dynamic data after static section
	// Field Field1: int256
	if _, err := abi.EncodeInt256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetCounterReturn to ABI bytes
func (value GetCounterReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetCounterReturn from ABI bytes in the provided buffer
func (t *GetCounterReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: int256
	t.Field1, _, err = abi.DecodeInt256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*GetTokenBalanceCall)(nil)

const GetTokenBalanceCallStaticSize = 64

var _ abi.Tuple = (*GetTokenBalanceCall)(nil)

// GetTokenBalanceCall represents an ABI tuple
type GetTokenBalanceCall struct {
	User  common.Address
	Token common.Address
}

// EncodedSize returns the total encoded size of GetTokenBalanceCall
func (t GetTokenBalanceCall) EncodedSize() int {
	dynamicSize := 0

	return GetTokenBalanceCallStaticSize + dynamicSize
}

// EncodeTo encodes GetTokenBalanceCall to ABI bytes in the provided buffer
func (value GetTokenBalanceCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetTokenBalanceCallStaticSize // Start dynamic data after static section
	// Field User: address
	if _, err := abi.EncodeAddress(value.User, buf[0:]); err != nil {
		return 0, err
	}

	// Field Token: address
	if _, err := abi.EncodeAddress(value.Token, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetTokenBalanceCall to ABI bytes
func (value GetTokenBalanceCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetTokenBalanceCall from ABI bytes in the provided buffer
func (t *GetTokenBalanceCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field User: address
	t.User, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Token: address
	t.Token, _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t GetTokenBalanceCall) GetMethodName() string {
	return "getTokenBalance"
}

// GetMethodID returns the function id
func (t GetTokenBalanceCall) GetMethodID() uint32 {
	return GetTokenBalanceID
}

// GetMethodSelector returns the function selector
func (t GetTokenBalanceCall) GetMethodSelector() [4]byte {
	return GetTokenBalanceSelector
}

// EncodeWithSelector encodes getTokenBalance arguments to ABI bytes including function selector
func (t GetTokenBalanceCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], GetTokenBalanceSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewGetTokenBalanceCall constructs a new GetTokenBalanceCall
func NewGetTokenBalanceCall(
	user common.Address,
	token common.Address,
) *GetTokenBalanceCall {
	return &GetTokenBalanceCall{
		User:  user,
		Token: token,
	}
}

const GetTokenBalanceReturnStaticSize = 32

var _ abi.Tuple = (*GetTokenBalanceReturn)(nil)

// GetTokenBalanceReturn represents an ABI tuple
type GetTokenBalanceReturn struct {
	Field1 *big.Int
}

// EncodedSize returns the total encoded size of GetTokenBalanceReturn
func (t GetTokenBalanceReturn) EncodedSize() int {
	dynamicSize := 0

	return GetTokenBalanceReturnStaticSize + dynamicSize
}

// EncodeTo encodes GetTokenBalanceReturn to ABI bytes in the provided buffer
func (value GetTokenBalanceReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := GetTokenBalanceReturnStaticSize // Start dynamic data after static section
	// Field Field1: uint256
	if _, err := abi.EncodeUint256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes GetTokenBalanceReturn to ABI bytes
func (value GetTokenBalanceReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes GetTokenBalanceReturn from ABI bytes in the provided buffer
func (t *GetTokenBalanceReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: uint256
	t.Field1, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

var _ abi.Method = (*OnPacketAcknowledgementCall)(nil)

const OnPacketAcknowledgementCallStaticSize = 160

var _ abi.Tuple = (*OnPacketAcknowledgementCall)(nil)

// OnPacketAcknowledgementCall represents an ABI tuple
type OnPacketAcknowledgementCall struct {
	ChannelId       string
	PortId          string
	Sequence        uint64
	Data            []byte
	Acknowledgement []byte
}

// EncodedSize returns the total encoded size of OnPacketAcknowledgementCall
func (t OnPacketAcknowledgementCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.ChannelId)
	dynamicSize += abi.SizeString(t.PortId)
	dynamicSize += abi.SizeBytes(t.Data)
	dynamicSize += abi.SizeBytes(t.Acknowledgement)

	return OnPacketAcknowledgementCallStaticSize + dynamicSize
}

// EncodeTo encodes OnPacketAcknowledgementCall to ABI bytes in the provided buffer
func (value OnPacketAcknowledgementCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := OnPacketAcknowledgementCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field ChannelId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.ChannelId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field PortId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.PortId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Sequence: uint64
	if _, err := abi.EncodeUint64(value.Sequence, buf[64:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Acknowledgement: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[128+24:128+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Acknowledgement, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes OnPacketAcknowledgementCall to ABI bytes
func (value OnPacketAcknowledgementCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes OnPacketAcknowledgementCall from ABI bytes in the provided buffer
func (t *OnPacketAcknowledgementCall) Decode(data []byte) (int, error) {
	if len(data) < 160 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 160
	// Decode dynamic field ChannelId
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field ChannelId")
		}
		t.ChannelId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field PortId
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PortId")
		}
		t.PortId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Sequence: uint64
	t.Sequence, _, err = abi.DecodeUint64(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Acknowledgement
	{
		offset := int(binary.BigEndian.Uint64(data[128+24 : 128+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Acknowledgement")
		}
		t.Acknowledgement, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t OnPacketAcknowledgementCall) GetMethodName() string {
	return "onPacketAcknowledgement"
}

// GetMethodID returns the function id
func (t OnPacketAcknowledgementCall) GetMethodID() uint32 {
	return OnPacketAcknowledgementID
}

// GetMethodSelector returns the function selector
func (t OnPacketAcknowledgementCall) GetMethodSelector() [4]byte {
	return OnPacketAcknowledgementSelector
}

// EncodeWithSelector encodes onPacketAcknowledgement arguments to ABI bytes including function selector
func (t OnPacketAcknowledgementCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], OnPacketAcknowledgementSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewOnPacketAcknowledgementCall constructs a new OnPacketAcknowledgementCall
func NewOnPacketAcknowledgementCall(
	channelId string,
	portId string,
	sequence uint64,
	data []byte,
	acknowledgement []byte,
) *OnPacketAcknowledgementCall {
	return &OnPacketAcknowledgementCall{
		ChannelId:       channelId,
		PortId:          portId,
		Sequence:        sequence,
		Data:            data,
		Acknowledgement: acknowledgement,
	}
}

// OnPacketAcknowledgementReturn represents the output arguments for onPacketAcknowledgement function
type OnPacketAcknowledgementReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*OnPacketTimeoutCall)(nil)

const OnPacketTimeoutCallStaticSize = 128

var _ abi.Tuple = (*OnPacketTimeoutCall)(nil)

// OnPacketTimeoutCall represents an ABI tuple
type OnPacketTimeoutCall struct {
	ChannelId string
	PortId    string
	Sequence  uint64
	Data      []byte
}

// EncodedSize returns the total encoded size of OnPacketTimeoutCall
func (t OnPacketTimeoutCall) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeString(t.ChannelId)
	dynamicSize += abi.SizeString(t.PortId)
	dynamicSize += abi.SizeBytes(t.Data)

	return OnPacketTimeoutCallStaticSize + dynamicSize
}

// EncodeTo encodes OnPacketTimeoutCall to ABI bytes in the provided buffer
func (value OnPacketTimeoutCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := OnPacketTimeoutCallStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field ChannelId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[0+24:0+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.ChannelId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field PortId: string
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeString(value.PortId, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Sequence: uint64
	if _, err := abi.EncodeUint64(value.Sequence, buf[64:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[96+24:96+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes OnPacketTimeoutCall to ABI bytes
func (value OnPacketTimeoutCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes OnPacketTimeoutCall from ABI bytes in the provided buffer
func (t *OnPacketTimeoutCall) Decode(data []byte) (int, error) {
	if len(data) < 128 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 128
	// Decode dynamic field ChannelId
	{
		offset := int(binary.BigEndian.Uint64(data[0+24 : 0+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field ChannelId")
		}
		t.ChannelId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field PortId
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field PortId")
		}
		t.PortId, n, err = abi.DecodeString(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode static field Sequence: uint64
	t.Sequence, _, err = abi.DecodeUint64(data[64:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[96+24 : 96+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t OnPacketTimeoutCall) GetMethodName() string {
	return "onPacketTimeout"
}

// GetMethodID returns the function id
func (t OnPacketTimeoutCall) GetMethodID() uint32 {
	return OnPacketTimeoutID
}

// GetMethodSelector returns the function selector
func (t OnPacketTimeoutCall) GetMethodSelector() [4]byte {
	return OnPacketTimeoutSelector
}

// EncodeWithSelector encodes onPacketTimeout arguments to ABI bytes including function selector
func (t OnPacketTimeoutCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], OnPacketTimeoutSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewOnPacketTimeoutCall constructs a new OnPacketTimeoutCall
func NewOnPacketTimeoutCall(
	channelId string,
	portId string,
	sequence uint64,
	data []byte,
) *OnPacketTimeoutCall {
	return &OnPacketTimeoutCall{
		ChannelId: channelId,
		PortId:    portId,
		Sequence:  sequence,
		Data:      data,
	}
}

// OnPacketTimeoutReturn represents the output arguments for onPacketTimeout function
type OnPacketTimeoutReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*ResetCounterCall)(nil)

// ResetCounterCall represents the input arguments for resetCounter function
type ResetCounterCall struct {
	abi.EmptyTuple
}

// GetMethodName returns the function name
func (t ResetCounterCall) GetMethodName() string {
	return "resetCounter"
}

// GetMethodID returns the function id
func (t ResetCounterCall) GetMethodID() uint32 {
	return ResetCounterID
}

// GetMethodSelector returns the function selector
func (t ResetCounterCall) GetMethodSelector() [4]byte {
	return ResetCounterSelector
}

// EncodeWithSelector encodes resetCounter arguments to ABI bytes including function selector
func (t ResetCounterCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], ResetCounterSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewResetCounterCall constructs a new ResetCounterCall
func NewResetCounterCall() *ResetCounterCall {
	return &ResetCounterCall{}
}

// ResetCounterReturn represents the output arguments for resetCounter function
type ResetCounterReturn struct {
	abi.EmptyTuple
}

var _ abi.Method = (*UserTokenBalancesCall)(nil)

const UserTokenBalancesCallStaticSize = 64

var _ abi.Tuple = (*UserTokenBalancesCall)(nil)

// UserTokenBalancesCall represents an ABI tuple
type UserTokenBalancesCall struct {
	Field1 common.Address
	Field2 common.Address
}

// EncodedSize returns the total encoded size of UserTokenBalancesCall
func (t UserTokenBalancesCall) EncodedSize() int {
	dynamicSize := 0

	return UserTokenBalancesCallStaticSize + dynamicSize
}

// EncodeTo encodes UserTokenBalancesCall to ABI bytes in the provided buffer
func (value UserTokenBalancesCall) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserTokenBalancesCallStaticSize // Start dynamic data after static section
	// Field Field1: address
	if _, err := abi.EncodeAddress(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	// Field Field2: address
	if _, err := abi.EncodeAddress(value.Field2, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes UserTokenBalancesCall to ABI bytes
func (value UserTokenBalancesCall) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserTokenBalancesCall from ABI bytes in the provided buffer
func (t *UserTokenBalancesCall) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field Field1: address
	t.Field1, _, err = abi.DecodeAddress(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field Field2: address
	t.Field2, _, err = abi.DecodeAddress(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// GetMethodName returns the function name
func (t UserTokenBalancesCall) GetMethodName() string {
	return "userTokenBalances"
}

// GetMethodID returns the function id
func (t UserTokenBalancesCall) GetMethodID() uint32 {
	return UserTokenBalancesID
}

// GetMethodSelector returns the function selector
func (t UserTokenBalancesCall) GetMethodSelector() [4]byte {
	return UserTokenBalancesSelector
}

// EncodeWithSelector encodes userTokenBalances arguments to ABI bytes including function selector
func (t UserTokenBalancesCall) EncodeWithSelector() ([]byte, error) {
	result := make([]byte, 4+t.EncodedSize())
	copy(result[:4], UserTokenBalancesSelector[:])
	if _, err := t.EncodeTo(result[4:]); err != nil {
		return nil, err
	}
	return result, nil
}

// NewUserTokenBalancesCall constructs a new UserTokenBalancesCall
func NewUserTokenBalancesCall(
	field1 common.Address,
	field2 common.Address,
) *UserTokenBalancesCall {
	return &UserTokenBalancesCall{
		Field1: field1,
		Field2: field2,
	}
}

const UserTokenBalancesReturnStaticSize = 32

var _ abi.Tuple = (*UserTokenBalancesReturn)(nil)

// UserTokenBalancesReturn represents an ABI tuple
type UserTokenBalancesReturn struct {
	Field1 *big.Int
}

// EncodedSize returns the total encoded size of UserTokenBalancesReturn
func (t UserTokenBalancesReturn) EncodedSize() int {
	dynamicSize := 0

	return UserTokenBalancesReturnStaticSize + dynamicSize
}

// EncodeTo encodes UserTokenBalancesReturn to ABI bytes in the provided buffer
func (value UserTokenBalancesReturn) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := UserTokenBalancesReturnStaticSize // Start dynamic data after static section
	// Field Field1: uint256
	if _, err := abi.EncodeUint256(value.Field1, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes UserTokenBalancesReturn to ABI bytes
func (value UserTokenBalancesReturn) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes UserTokenBalancesReturn from ABI bytes in the provided buffer
func (t *UserTokenBalancesReturn) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field Field1: uint256
	t.Field1, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// Event signatures
var (
	// CounterIncremented(int256,address)
	CounterIncrementedEventTopic = common.Hash{0xea, 0x6f, 0xce, 0xa9, 0x21, 0x0b, 0x42, 0x26, 0xb3, 0xbb, 0x7e, 0x55, 0xff, 0xa1, 0x8b, 0xf0, 0x72, 0x03, 0x6d, 0x64, 0x07, 0x3f, 0x55, 0x53, 0x33, 0x6e, 0xe9, 0xbe, 0xf3, 0x03, 0xc2, 0xf0}
	// PacketAcknowledged(string,string,uint64,bytes,bytes)
	PacketAcknowledgedEventTopic = common.Hash{0x42, 0x61, 0x12, 0x85, 0xd4, 0x63, 0x4f, 0x96, 0xd3, 0xf7, 0x41, 0x58, 0x4f, 0x4f, 0x89, 0x60, 0x03, 0xf5, 0x92, 0x53, 0xc3, 0xc7, 0xa4, 0x04, 0x72, 0xcb, 0xf0, 0x05, 0x3e, 0x72, 0x6b, 0x5f}
	// PacketTimedOut(string,string,uint64,bytes)
	PacketTimedOutEventTopic = common.Hash{0x1e, 0x0d, 0x6d, 0x3f, 0x26, 0xf1, 0xac, 0x73, 0x8b, 0x3c, 0x50, 0xc7, 0x7a, 0xc3, 0xe7, 0x93, 0x18, 0x53, 0xb7, 0x3d, 0x3c, 0x75, 0x4e, 0xba, 0x1e, 0xc9, 0xea, 0x2d, 0xfb, 0x04, 0x42, 0xc8}
	// TokensDeposited(address,address,uint256,uint256)
	TokensDepositedEventTopic = common.Hash{0x9d, 0x57, 0x2f, 0x81, 0x9a, 0xe4, 0xf4, 0xb4, 0x83, 0x9d, 0xda, 0x54, 0xbc, 0xb4, 0xcc, 0x8d, 0x7c, 0x2f, 0x0a, 0x67, 0x80, 0x7d, 0xb8, 0x64, 0x71, 0x6b, 0x20, 0xea, 0xfb, 0x51, 0x53, 0x59}
)

// CounterIncrementedEvent represents the CounterIncremented event
var _ abi.Event = (*CounterIncrementedEvent)(nil)

type CounterIncrementedEvent struct {
	CounterIncrementedEventIndexed
	CounterIncrementedEventData
}

// NewCounterIncrementedEvent constructs a new CounterIncremented event
func NewCounterIncrementedEvent(
	newValue *big.Int,
	user common.Address,
) *CounterIncrementedEvent {
	return &CounterIncrementedEvent{
		CounterIncrementedEventIndexed: CounterIncrementedEventIndexed{
			User: user,
		},
		CounterIncrementedEventData: CounterIncrementedEventData{
			NewValue: newValue,
		},
	}
}

// GetEventName returns the event name
func (e CounterIncrementedEvent) GetEventName() string {
	return "CounterIncremented"
}

// GetEventID returns the event ID (topic)
func (e CounterIncrementedEvent) GetEventID() common.Hash {
	return CounterIncrementedEventTopic
}

// CounterIncremented represents an ABI event
type CounterIncrementedEventIndexed struct {
	User common.Address
}

// EncodeTopics encodes indexed fields of CounterIncremented event to topics
func (e CounterIncrementedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 2)
	topics = append(topics, CounterIncrementedEventTopic)
	{
		// User
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.User, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of CounterIncremented event from topics, ignore hash topics
func (e *CounterIncrementedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 2 {
		return fmt.Errorf("invalid number of topics for CounterIncremented event: expected 2, got %d", len(topics))
	}
	if topics[0] != CounterIncrementedEventTopic {
		return fmt.Errorf("invalid event topic for CounterIncremented event")
	}
	var err error
	e.User, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	return nil
}

const CounterIncrementedEventDataStaticSize = 32

var _ abi.Tuple = (*CounterIncrementedEventData)(nil)

// CounterIncrementedEventData represents an ABI tuple
type CounterIncrementedEventData struct {
	NewValue *big.Int
}

// EncodedSize returns the total encoded size of CounterIncrementedEventData
func (t CounterIncrementedEventData) EncodedSize() int {
	dynamicSize := 0

	return CounterIncrementedEventDataStaticSize + dynamicSize
}

// EncodeTo encodes CounterIncrementedEventData to ABI bytes in the provided buffer
func (value CounterIncrementedEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := CounterIncrementedEventDataStaticSize // Start dynamic data after static section
	// Field NewValue: int256
	if _, err := abi.EncodeInt256(value.NewValue, buf[0:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes CounterIncrementedEventData to ABI bytes
func (value CounterIncrementedEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes CounterIncrementedEventData from ABI bytes in the provided buffer
func (t *CounterIncrementedEventData) Decode(data []byte) (int, error) {
	if len(data) < 32 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 32
	// Decode static field NewValue: int256
	t.NewValue, _, err = abi.DecodeInt256(data[0:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}

// PacketAcknowledgedEvent represents the PacketAcknowledged event
var _ abi.Event = (*PacketAcknowledgedEvent)(nil)

type PacketAcknowledgedEvent struct {
	PacketAcknowledgedEventIndexed
	PacketAcknowledgedEventData
}

// NewPacketAcknowledgedEvent constructs a new PacketAcknowledged event
func NewPacketAcknowledgedEvent(
	channelId string,
	portId string,
	sequence uint64,
	data []byte,
	acknowledgement []byte,
) *PacketAcknowledgedEvent {
	return &PacketAcknowledgedEvent{
		PacketAcknowledgedEventIndexed: PacketAcknowledgedEventIndexed{
			ChannelId: channelId,
			PortId:    portId,
		},
		PacketAcknowledgedEventData: PacketAcknowledgedEventData{
			Sequence:        sequence,
			Data:            data,
			Acknowledgement: acknowledgement,
		},
	}
}

// GetEventName returns the event name
func (e PacketAcknowledgedEvent) GetEventName() string {
	return "PacketAcknowledged"
}

// GetEventID returns the event ID (topic)
func (e PacketAcknowledgedEvent) GetEventID() common.Hash {
	return PacketAcknowledgedEventTopic
}

// PacketAcknowledged represents an ABI event
type PacketAcknowledgedEventIndexed struct {
	ChannelId string
	PortId    string
}

// EncodeTopics encodes indexed fields of PacketAcknowledged event to topics
func (e PacketAcknowledgedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, PacketAcknowledgedEventTopic)
	{
		// ChannelId
		encodedSize := abi.SizeString(e.ChannelId)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.ChannelId, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	{
		// PortId
		encodedSize := abi.SizeString(e.PortId)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.PortId, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of PacketAcknowledged event from topics, ignore hash topics
func (e *PacketAcknowledgedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return fmt.Errorf("invalid number of topics for PacketAcknowledged event: expected 3, got %d", len(topics))
	}
	if topics[0] != PacketAcknowledgedEventTopic {
		return fmt.Errorf("invalid event topic for PacketAcknowledged event")
	}
	return nil
}

const PacketAcknowledgedEventDataStaticSize = 96

var _ abi.Tuple = (*PacketAcknowledgedEventData)(nil)

// PacketAcknowledgedEventData represents an ABI tuple
type PacketAcknowledgedEventData struct {
	Sequence        uint64
	Data            []byte
	Acknowledgement []byte
}

// EncodedSize returns the total encoded size of PacketAcknowledgedEventData
func (t PacketAcknowledgedEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.Data)
	dynamicSize += abi.SizeBytes(t.Acknowledgement)

	return PacketAcknowledgedEventDataStaticSize + dynamicSize
}

// EncodeTo encodes PacketAcknowledgedEventData to ABI bytes in the provided buffer
func (value PacketAcknowledgedEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := PacketAcknowledgedEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Sequence: uint64
	if _, err := abi.EncodeUint64(value.Sequence, buf[0:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	// Field Acknowledgement: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[64+24:64+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Acknowledgement, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes PacketAcknowledgedEventData to ABI bytes
func (value PacketAcknowledgedEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes PacketAcknowledgedEventData from ABI bytes in the provided buffer
func (t *PacketAcknowledgedEventData) Decode(data []byte) (int, error) {
	if len(data) < 96 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 96
	// Decode static field Sequence: uint64
	t.Sequence, _, err = abi.DecodeUint64(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	// Decode dynamic field Acknowledgement
	{
		offset := int(binary.BigEndian.Uint64(data[64+24 : 64+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Acknowledgement")
		}
		t.Acknowledgement, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// PacketTimedOutEvent represents the PacketTimedOut event
var _ abi.Event = (*PacketTimedOutEvent)(nil)

type PacketTimedOutEvent struct {
	PacketTimedOutEventIndexed
	PacketTimedOutEventData
}

// NewPacketTimedOutEvent constructs a new PacketTimedOut event
func NewPacketTimedOutEvent(
	channelId string,
	portId string,
	sequence uint64,
	data []byte,
) *PacketTimedOutEvent {
	return &PacketTimedOutEvent{
		PacketTimedOutEventIndexed: PacketTimedOutEventIndexed{
			ChannelId: channelId,
			PortId:    portId,
		},
		PacketTimedOutEventData: PacketTimedOutEventData{
			Sequence: sequence,
			Data:     data,
		},
	}
}

// GetEventName returns the event name
func (e PacketTimedOutEvent) GetEventName() string {
	return "PacketTimedOut"
}

// GetEventID returns the event ID (topic)
func (e PacketTimedOutEvent) GetEventID() common.Hash {
	return PacketTimedOutEventTopic
}

// PacketTimedOut represents an ABI event
type PacketTimedOutEventIndexed struct {
	ChannelId string
	PortId    string
}

// EncodeTopics encodes indexed fields of PacketTimedOut event to topics
func (e PacketTimedOutEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, PacketTimedOutEventTopic)
	{
		// ChannelId
		encodedSize := abi.SizeString(e.ChannelId)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.ChannelId, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	{
		// PortId
		encodedSize := abi.SizeString(e.PortId)
		buf := make([]byte, encodedSize)
		if _, err := abi.EncodeString(e.PortId, buf); err != nil {
			return nil, err
		}
		hash := crypto.Keccak256Hash(buf)
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of PacketTimedOut event from topics, ignore hash topics
func (e *PacketTimedOutEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return fmt.Errorf("invalid number of topics for PacketTimedOut event: expected 3, got %d", len(topics))
	}
	if topics[0] != PacketTimedOutEventTopic {
		return fmt.Errorf("invalid event topic for PacketTimedOut event")
	}
	return nil
}

const PacketTimedOutEventDataStaticSize = 64

var _ abi.Tuple = (*PacketTimedOutEventData)(nil)

// PacketTimedOutEventData represents an ABI tuple
type PacketTimedOutEventData struct {
	Sequence uint64
	Data     []byte
}

// EncodedSize returns the total encoded size of PacketTimedOutEventData
func (t PacketTimedOutEventData) EncodedSize() int {
	dynamicSize := 0
	dynamicSize += abi.SizeBytes(t.Data)

	return PacketTimedOutEventDataStaticSize + dynamicSize
}

// EncodeTo encodes PacketTimedOutEventData to ABI bytes in the provided buffer
func (value PacketTimedOutEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := PacketTimedOutEventDataStaticSize // Start dynamic data after static section
	var (
		err error
		n   int
	)
	// Field Sequence: uint64
	if _, err := abi.EncodeUint64(value.Sequence, buf[0:]); err != nil {
		return 0, err
	}

	// Field Data: bytes
	// Encode offset pointer
	binary.BigEndian.PutUint64(buf[32+24:32+32], uint64(dynamicOffset))
	// Encode dynamic data
	n, err = abi.EncodeBytes(value.Data, buf[dynamicOffset:])
	if err != nil {
		return 0, err
	}
	dynamicOffset += n

	return dynamicOffset, nil
}

// Encode encodes PacketTimedOutEventData to ABI bytes
func (value PacketTimedOutEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes PacketTimedOutEventData from ABI bytes in the provided buffer
func (t *PacketTimedOutEventData) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
		n   int
	)
	dynamicOffset := 64
	// Decode static field Sequence: uint64
	t.Sequence, _, err = abi.DecodeUint64(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode dynamic field Data
	{
		offset := int(binary.BigEndian.Uint64(data[32+24 : 32+32]))
		if offset != dynamicOffset {
			return 0, errors.New("invalid offset for dynamic field Data")
		}
		t.Data, n, err = abi.DecodeBytes(data[dynamicOffset:])
		if err != nil {
			return 0, err
		}
		dynamicOffset += n
	}
	return dynamicOffset, nil
}

// TokensDepositedEvent represents the TokensDeposited event
var _ abi.Event = (*TokensDepositedEvent)(nil)

type TokensDepositedEvent struct {
	TokensDepositedEventIndexed
	TokensDepositedEventData
}

// NewTokensDepositedEvent constructs a new TokensDeposited event
func NewTokensDepositedEvent(
	user common.Address,
	token common.Address,
	amount *big.Int,
	newBalance *big.Int,
) *TokensDepositedEvent {
	return &TokensDepositedEvent{
		TokensDepositedEventIndexed: TokensDepositedEventIndexed{
			User:  user,
			Token: token,
		},
		TokensDepositedEventData: TokensDepositedEventData{
			Amount:     amount,
			NewBalance: newBalance,
		},
	}
}

// GetEventName returns the event name
func (e TokensDepositedEvent) GetEventName() string {
	return "TokensDeposited"
}

// GetEventID returns the event ID (topic)
func (e TokensDepositedEvent) GetEventID() common.Hash {
	return TokensDepositedEventTopic
}

// TokensDeposited represents an ABI event
type TokensDepositedEventIndexed struct {
	User  common.Address
	Token common.Address
}

// EncodeTopics encodes indexed fields of TokensDeposited event to topics
func (e TokensDepositedEventIndexed) EncodeTopics() ([]common.Hash, error) {
	topics := make([]common.Hash, 0, 3)
	topics = append(topics, TokensDepositedEventTopic)
	{
		// User
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.User, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	{
		// Token
		var hash common.Hash
		if _, err := abi.EncodeAddress(e.Token, hash[:]); err != nil {
			return nil, err
		}
		topics = append(topics, hash)
	}
	return topics, nil
}

// DecodeTopics decodes indexed fields of TokensDeposited event from topics, ignore hash topics
func (e *TokensDepositedEventIndexed) DecodeTopics(topics []common.Hash) error {
	if len(topics) != 3 {
		return fmt.Errorf("invalid number of topics for TokensDeposited event: expected 3, got %d", len(topics))
	}
	if topics[0] != TokensDepositedEventTopic {
		return fmt.Errorf("invalid event topic for TokensDeposited event")
	}
	var err error
	e.User, _, err = abi.DecodeAddress(topics[1][:])
	if err != nil {
		return err
	}
	e.Token, _, err = abi.DecodeAddress(topics[2][:])
	if err != nil {
		return err
	}
	return nil
}

const TokensDepositedEventDataStaticSize = 64

var _ abi.Tuple = (*TokensDepositedEventData)(nil)

// TokensDepositedEventData represents an ABI tuple
type TokensDepositedEventData struct {
	Amount     *big.Int
	NewBalance *big.Int
}

// EncodedSize returns the total encoded size of TokensDepositedEventData
func (t TokensDepositedEventData) EncodedSize() int {
	dynamicSize := 0

	return TokensDepositedEventDataStaticSize + dynamicSize
}

// EncodeTo encodes TokensDepositedEventData to ABI bytes in the provided buffer
func (value TokensDepositedEventData) EncodeTo(buf []byte) (int, error) {
	// Encode tuple fields
	dynamicOffset := TokensDepositedEventDataStaticSize // Start dynamic data after static section
	// Field Amount: uint256
	if _, err := abi.EncodeUint256(value.Amount, buf[0:]); err != nil {
		return 0, err
	}

	// Field NewBalance: uint256
	if _, err := abi.EncodeUint256(value.NewBalance, buf[32:]); err != nil {
		return 0, err
	}

	return dynamicOffset, nil
}

// Encode encodes TokensDepositedEventData to ABI bytes
func (value TokensDepositedEventData) Encode() ([]byte, error) {
	buf := make([]byte, value.EncodedSize())
	if _, err := value.EncodeTo(buf); err != nil {
		return nil, err
	}
	return buf, nil
}

// Decode decodes TokensDepositedEventData from ABI bytes in the provided buffer
func (t *TokensDepositedEventData) Decode(data []byte) (int, error) {
	if len(data) < 64 {
		return 0, io.ErrUnexpectedEOF
	}
	var (
		err error
	)
	dynamicOffset := 64
	// Decode static field Amount: uint256
	t.Amount, _, err = abi.DecodeUint256(data[0:])
	if err != nil {
		return 0, err
	}
	// Decode static field NewBalance: uint256
	t.NewBalance, _, err = abi.DecodeUint256(data[32:])
	if err != nil {
		return 0, err
	}
	return dynamicOffset, nil
}
